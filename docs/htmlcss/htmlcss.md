# «Основы HTML и CSS»

## HTML
HTML расшифровывается как `«Hypertext Markup Language»`, то есть «язык гипертекстовой разметки».

Язык HTML отвечает за структуру и содержание страницы. HTML состоит из тегов, а тег состоит из имени, заключённого между знаками «меньше» и «больше». Примеры тегов: `<h1>`, `<p>`, `<ul>`.

## Одиночные теги
Существуют не только парные, но и одиночные теги. Например, тег `<img>` позволяет добавить картинку в разметку.

Сам по себе `<img>` не имеет смысла. Чтобы этот тег был действительно полезен, необходимо написать внутри него адрес, ведущий к картинке. Делается это с помощью атрибута src:

```html
<img src="keks.png">
```

У тега может быть несколько атрибутов. В этом случае они пишутся через пробел:

```html
<тег атрибут1="значение1" атрибут2="значение2">
```

Например, картинке при желании можно задать размеры:

```html
<img src="keks.png" width="200" height="100">
```

## Парные теги
Теги бывают парными и одиночными. Парные теги могут содержать текст и другие теги. У парных тегов, в отличие от одиночных, есть вторая половинка — закрывающий тег:

```html
<h1>Текст заголовка</h1>
```

В закрывающей части парных тегов перед именем ставится символ / («слэш»).

В парные теги можно вкладывать другие теги. Например, как в списках:

```html
<ul>
  <li>Элемент списка</li>
</ul>
```

У вложенных тегов всегда нужно следить за правильным порядком закрытия. Вложенный тег не может закрываться позже родительского:

```html
<ul><li>Элемент списка</ul></li> <!-- Плохо  -->
<ul><li>Элемент списка</li></ul> <!-- Хорошо -->
```

Не все теги можно вкладывать в другие теги, например, тег `<h1>` нельзя вкладывать в `<p>`.

## Комментарии
Код, заключённый между символами `<!--` и `-->`, работать не будет. Если эти символы удалить, то код заработает, это называется «раскомментировать». С помощью комментариев обычно временно отключают какой-то код или оставляют подсказки и разъяснения.

```html
<!-- Это комментарий в HTML -->
```

## CSS
CSS расшифровывается как `«Cascading Style Sheets»`, то есть «каскадные таблицы стилей».

Язык CSS отвечает за внешний вид страницы.

С помощью CSS можно задавать параметры для любого тега: ширину и высоту, отступы, цвет и размер шрифта, фон и так далее. Все эти параметры задаются с помощью свойств в следующем формате:

```html
свойство: значение;
```

Например:

```html
color: red;
padding: 10px;
```
Стили к тегам добавляются чаще всего при помощи атрибута class.


Например, если мы хотим, чтобы определённые стили, описанные, допустим, в классе feature-kitten, применились к тегу `<p>`, то в разметке напишем так:

```html
<p class="feature-kitten">...</p>
```


## CSS-правила
Можно сказать, что CSS-правило — это группа свойств и их значений, которая целиком применяется к тем тегам, на которые указывает селектор.

И выглядит это так:

```html
селектор {
  свойство1: значение;
  свойство2: значение;
}
```

Задавать стили можно не только с помощью атрибута class, но и по тегам. Селектор указывает, к каким тегам применятся свойства из CSS-правила. Селекторы по тегам работают проще всего: они выбирают все теги с подходящим именем.

```html
p { color: red; }
```

В примере селектором является p, и он выбирает все теги с именем p (то есть теги `<p>`), а теги с другим именем, например h1, не выбирает.

Когда же стилизация задаётся по классам, то стили применяются только к тегам с такими классами.

```html
.название_класса {
  свойство: значение;
}
```

## Миксование классов
У HTML-элемента может быть сколько угодно классов, в этом случае они перечисляются в атрибуте class через пробел, например:

```html
<li class="product">Товар</li>
<li class="product hit">Товар, а ещё хит продаж</li>
<li class="product hit sale">Товар, хит продаж и со ски-и-идкой!</li>
```

Обычно миксование используют так: в один класс выносят общее оформление, а в дополнительных классах описывают его модификации.

## Переопределение стилей

Чтобы задать всем товарам один цвет фона, а хитам другой, можно сделать так:


```css
.product {
  …                         /* общие размеры и отступы */
  background-color: gray;   /* серый фон по умолчанию */
}

.hit {
  background-color: yellow; /* жёлтый фон у хитов */
}
```

Оба CSS-правила подействуют на второй товар, ведь у него есть два подходящих класса. Но чтобы цвет фона стал жёлтым, правило .hit должно находиться в коде ниже правила .product. В этом случае свойство background-color из второго правила переопределит значение свойства background-color из первого правила.


## Комментарии
В CSS тоже существуют комментарии, их отличие от HTML-комментариев в том, что код или подсказки пишутся между символами `/*` и `*/`.



# «Структура HTML-документа»
Каждый HTML-документ начинается с декларации типа документа или «доктайпа». Тип документа необходим, чтобы браузер мог определить версию HTML и правильно отобразить страницу.

```html
<!DOCTYPE html>
```

Простейшая HTML-страница состоит как минимум из трёх тегов: `<html>`, `<head>` и `<body>`. Тег `<head>` обычно содержит заголовок, ключевые слова, описание страницы и другие служебные данные. Также внутри него подключаются внешние ресурсы, например, стили. Содержимое этого тега не отображается на странице напрямую. А в теге `<body>` хранится содержание страницы, которое отображается в окне браузера.

Для подключения стилей к странице существует тег `<link>`. Для этого у него есть атрибут href в котором задаётся адрес стилевого файла, а значение stylesheet атрибута rel говорит браузеру, что мы подключаем именно стили, а не что-то другое.

```html
<head>
  <link href="адрес_файла_стилей.css" rel="stylesheet">
</head>
```

Ещё один элемент, который располагается в `<head>` — это тег `<title>`. В нём задаётся заголовок страницы, который отображается во вкладках браузера. По заголовку должно быть понятно, о чём эта страница, даже когда она не открыта в браузере, а отображается в результатах поиска или в браузерных закладках.

```html
<head>
  <title>Тренажёры — HTML Academy</title>
</head>
```

Ещё один важный тег, располагающийся внутри `<head>` это тег `<meta>`. Он одиночный, то есть не требует парный закрывающий тег в конце. С помощью `<meta>` можно сообщать браузеру, поисковому роботу или другому устройству различную служебную информацию (или метаинформацию) о вашем сайте: кодировку текста, описание контента и так далее. Для этого используются теги `<meta>` с разными атрибутами и их значениями.

Кодировка текста HTML-страницы указывается с помощью атрибута charset:

```html
<meta charset="название кодировки">
```

Самая распространённая современная кодировка — `utf-8`.

Перечень ключевых слов задаётся тегом `<meta>`, у которого атрибут name имеет значение `keywords`. Ключевые слова (самые важные слова из содержания страницы) перечисляются в атрибуте content через запятую:

```html
<meta name="keywords" content="важные, ключевые, слова">
```

Краткое описание (или аннотация) страницы задаётся похожим образом, только значение атрибута name меняется на description:

```html
<meta name="description" content="краткое описание">
```

Внутри `<body>` находятся те теги, которые отображаются на странице. Например, тег `<main>` выделяет основное содержание страницы, которое не повторяется на других страницах. И обычно на странице используется один `<main>`.

Спецификация не допускает использование на одной странице более одного тега `<main>`, если у них нет специального атрибута hidden. Этот атрибут добавляется HTML-элементу, например, в одностраничных приложениях (Single Page Application), чтобы менять содержимое страницы, делая видимым тот или иной `<main>` в разных состояниях приложения. Атрибут hidden указывает браузеру, что элемент не должен отображаться и использоваться в момент, когда отображается и используется содержимое другого `<main>`.


Тег `<header>` содержит вводную часть страницы, которую чаще называют «шапкой», а тег `<footer>` описывает заключительную часть страницы, или «подвал». Существует тег `<section>`, который обозначает крупный смысловой (или «логический») раздел.

Тег `<header>` — это не только шапка сайта с логотипом и меню, он может использоваться, например, и как «шапка» какой-нибудь статьи или раздела сайта. Конечно, в случае со статьёй `<header>` называют не «шапкой», а вводной частью, в которой могут содержаться заголовки, оглавление и так далее.

С `<footer>` ситуация аналогичная. В привычном понимании это подвал сайта, с копирайтами, контактной информацией и так далее. Но `<footer>` может использоваться и в других разделах сайта. Например, внутри статьи в «подвале» можно разместить дополнительную информацию: данные об авторе, дополнительные ссылки и так далее.

Тег `<article>`, обозначает цельный, законченный и самостоятельный фрагмент информации.

Для создания логического раздела с основной навигацией предназначен тег `<nav>` (сокращение от английского «navigation»). Обычно в `<nav>` включают ссылки на другие страницы или навигацию по текущей странице.

Тег `<aside>` включает в себя дополнительное содержание, не связанное напрямую с основным. Такие блоки ещё часто называют «сайдбарами» или боковыми панелями.


Небольшая подсказка как отличать смысловые или логические разделы от структурных разделов. Логический раздел вы можете осмысленно назвать одним словом или словосочетанием: «программа обучения», «каталог», «наши преимущества». Если же в голову приходят названия, которые указывают на его положение на странице («шапка», «подвал», «левая колонка»), либо перечисления («новости и галерея», «фильтры и товары»), в таком случае раздел структурный и тег `<section>` для него не подходит.

Не каждая группа ссылок на странице должна быть обёрнута в `<nav>`. Например, небольшой блок со вспомогательными ссылками в подвале сайта. Такой блок внутри тега `<footer>` не нужно дополнительно оборачивать в тег `<nav>`.

Кроме того, блок `<nav>` помимо ссылок может включать абзацы с текстом, заголовки, списки и другое содержание.

Теги `<section>` можно использовать внутри `<article>`, если там нужно выделить отдельные смысловые блоки.

Точно так же можно использовать `<article>` внутри `<section>`, если в логическом разделе документа содержатся независимые контентные блоки.




Для создания основной структуры текста используют заголовки. В HTML существует целое семейство заголовочных тегов: от `<h1>` до `<h6>`. Тег `<h1>` обозначает самый важный заголовок (заголовок верхнего уровня), а тег `<h6>` обозначает подзаголовок самого нижнего уровня.

```html
<h1>Спецификация HTML</h1>
<h2>Раздел 1 Введение</h2>
<h3>Раздел 1.1 Происхождение языка</h3>
```

Основную структуру текста создают с помощью заголовков, а более мелкую выстраивают с помощью параграфов (или абзацев). Для разметки параграфов предназначен тег `<p>`. По умолчанию абзацы начинаются с новой строки и отделяются от остального контента отступами сверху и снизу.

В пятой версии HTML разрешили использовать собственную, независимую от остального документа, иерархию заголовков в тегах для создания смысловых разделов. Теперь на странице можно использовать несколько `<section>` или `<article>` со своими `<h1>`, `<h2>` и `<h3>`.

На практике выяснилось, что этот механизм скорее мешает, чем помогает, а браузеры и средства доступности не спешат его реализовывать. Так что все начали возвращаться к старой доброй сквозной иерархии заголовков во всём документе.

Абзац — отрезок письменной речи, состоящий из одного или нескольких предложений, зачастую объединённых общей мыслью. Это привычное нам определение. Параграф в HTML совсем другой.

Параграфы в HTML — это всего лишь неразрывная последовательность фразовых элементов, то есть чисто структурная, а не смысловая сущность. Параграфы существуют даже без тега `<p>`.

А тег `<p>` позволяет лишь явно выделять параграфы, группируя элементы с фразовым типом содержимого. И это могут быть не только блоки текста, а, например, изображения, ссылки или поля ввода.

Не все теги могут быть включены в `<p>`. Например, внутри абзаца не могут располагаться крупные структурные теги, заголовки, формы, списки, таблицы. Когда браузер встречает неподходящий тег внутри `<p>`, он «выбрасывает» этот тег из `<p>`.


`<meta>`, `<link>`, `<title>` и другие теги, включаемые в `<head>`, имеют особый тип содержимого — метасодержимое. Они не отображаются на странице напрямую, а служат для хранения информации о документе и для взаимосвязи документа с другими документами и системами.

#  «Разметка текста»
## Списки
### Неупорядоченный список
Тег `<ul>` (сокращение от «unordered list»). Используется, когда порядок элементов не важен. Например, для разметки перечня ссылок в меню, преимуществ товара, ингредиентов в составе продукта.

Непосредственно в теге `<ul>` могут находиться только теги `<li>` (сокращение от «list item»), которые обозначают элементы или пункты списка:


```html
<ul>
  <li>Я пункт списка, могу быть на любом месте</li>
  <li>И я пункт списка, и мне тоже не важен порядок</li>
</ul>
```

По умолчанию элементы `<ul>` отмечаются маркерами такого же цвета, как цвет текста.

Я пункт списка, могу быть на любом месте
И я пункт списка, и мне тоже не важен порядок

### Упорядоченный список
Тег `<ol>` (сокращение от «ordered list»). В этом списке действительно важно, в каком порядке идут элементы. Упорядоченные списки подходят для разметки алгоритмов, инструкций, рецептов, результатов соревнований и так далее.

Пункты упорядоченного списка тоже размечаются с помощью тега `<li>`. Пример кода:

```html
<ol>
  <li>Я первый и только первый пункт</li>
  <li>Я не я, если я не второй пункт</li>
  <li>Третий после стольких лет? Всегда!</li>
</ol>
```

По умолчанию перед элементами `<ol>` ставится их порядковый номер.

Я первый и только первый пункт<br>
Я не я, если я не второй пункт<br>
Третий после стольких лет? Всегда!<br>

У `<ol>` может быть несколько атрибутов: start, reversed и type.

Атрибут start меняет стартовое число нумерации пунктов. Может быть отрицательным.

Атрибут reversed меняет направление нумерации на противоположный. Этот атрибут не требует значения.

С помощью атрибута type можно задавать различные типы маркеров: строчные и заглавные латинские буквы или римские цифры.

### Вложенные списки

Теги `<ol>` и `<ul>` можно вкладывать друг в друга и создавать многоуровневые списки. Количество уровней в списках не ограничено.

Сначала нужно создать список первого уровня, а затем между тегами `<li>` и `</li>` этого списка добавить ещё один список. При этом необходимо аккуратно закрывать все теги:

```html
<ol>
  <li>1
    <ul>
      <li>1.1</li>
      <li>1.2</li>
    </ul>
  </li>
  <li>2</li>
</ol>
```

### Список описаний
Тег `<dl>` (сокращение от «description list»). Список описаний используется для разметки вопросов-ответов, наименований и определений, категорий и тем. Он создаётся с помощью трёх тегов:

```html
<dl> обозначает сам список описаний;
<dt> (сокращение от «description term») обозначает термин;
<dd> (сокращение от «description definition») обозначает описание или определение.
```

Теги `<dt>` и `<dd>` пишутся внутри `<dl>`. Каждый список `<dl>` может содержать один или несколько терминов и одно или несколько описаний для каждого термина. Пример кода:

```html
<dl>
  <dt>HTML</dt>
  <dd>Язык гипертекстовой разметки</dd>
  <dt>CSS</dt>
  <dd>Каскадные таблицы стилей</dd>
  <dd>Язык для оформления HTML-документов</dd>
</dl>
```

По умолчанию браузер добавляет небольшой отступ слева от определений.

### Преформатированный текст и код
Тег `<pre>` (сокращение от «preformatted text»). Используется для отображения примеров кода, также применяется для отображения картинок ASCII Art. Браузер сохраняет и отображает все пробелы и переносы, которые есть внутри тега `<pre>`.

```html
<pre>Пример
        преформатированного
        текста     с сохранёнными пробелами
                     и переносами строк</pre>
```

Тег `<code>`. Используется для обозначения фрагментов кода.

С его помощью размечается любой фрагмент текста, который распознается компьютером: код программы, разметки, название файла и так далее. Обычно браузеры отображают текст в теге `<code>` моноширинным шрифтом.


Тег `<code>`ul`</code>` — это неупорядоченный список.
Тег ul — это неупорядоченный список.
Тег `<code>` можно вкладывать внутрь тега `<pre>`.

### Цитаты
### Небольшие цитаты
Тег `<q>` (сокращение от «quote»). Предназначен для выделения цитат внутри предложения. Текст внутри тега браузер автоматически обрамляет кавычками, поэтому добавлять кавычки вручную не нужно.

### Источник цитат
Тег `<cite>`. В нём можно указывать помимо адреса источника цитаты ещё и название произведения, откуда цитируется текст, а также имя автора или организации, чей текст цитируется. Содержимое `<cite>` в браузере выделяется курсивом.

```html
<p>По словам <cite>Чарльза Буковски</cite> — <q>Интеллектуал о простой вещи говорит сложно — художник сложную вещь описывает простыми словами.</q></p>
По словам Чарльза Буковски — Интеллектуал о простой вещи говорит сложно — художник сложную вещь описывает простыми словами.
```

Тег `<cite>` может быть самостоятельным и не привязываться к цитате:

```html
<p>Какой доктор ваш любимый (в сериале <cite>Доктор Кто</cite>)?</p>
```

### Длинные цитаты
Тег `<blockquote>`. Предназначен для выделения длинных цитат, которые могут состоять из нескольких абзацев. Тег выделяет цитату не как фрагмент текста в предложении, а как отдельный блок текста с отступами.

```html
<blockquote>
  <p>Ум ценится дорого, когда дешевеет сила.</p>
  <cite>Джейсон Стэтхэм</cite>
</blockquote>
```

В браузере контенту тега `<blockquote>` обычно добавляется дополнительный отступ слева и справа.

## Разметка фрагментов текста
### Символы-мнемоники
Это особые строки, которые начинаются с амперсанда (&) и заканчиваются точкой с запятой (;). Например, знак меньше на страницу можно вставить мнемоникой `&lt;` (less than), а знак больше мнемоникой `&gt;` (greater than):

Некоторые символы в HTML зарезервированы, то есть браузер считает их HTML-кодом. Например, любой текст после знака меньше (<) браузер будет пытаться интерпретировать как тег и на странице не отобразит. Чтобы использовать специальные символы в тексте страницы как обычные символы их нужно заменить на символы-мнемоники.

```html
&lt;ul&gt;
&lt;/ul&gt;
<ul>
</ul>
```

### Перенос строк
Тег `<br>` (сокращение от «line break»). Применяется, чтобы вставить в текст перенос строки, не создавая при этом абзац. Например, при разметке стихов или текстов песен.

### Верхний и нижний индексы
Теги `<sup>` и `<sub>`. Названия образованы от слов «superscript» и «subscript».

Тег `<sup>` отображает текст в виде верхнего индекса, а `<sub>` отображает текст в виде нижнего индекса.

Их используют для указания единиц измерения или для написания простых формул:

```html
20м<sup>2</sup>
H<sub>2</sub>O
X<sup>3</sup>+X<sup>2</sup>=1
```

20м<sup>2</sup>
H<sub>2</sub>O
X<sup>3</sup>+X<sup>2</sup>=1

Для создания более сложных формул, эти теги можно использовать внутри друг друга.

### Дата и время
Тег `<time>`. С помощью него можно описывать даты одновременно и для человека, и для машины. Для указания даты в машиночитаемом формате ISO 8601 существует атрибут datetime и выглядит так:

```html
<time datetime="2016-11-18T09:54">09:54 утра</time>

<time datetime="2015-11-18">18 ноября 2015</time>

<time datetime="2018-09-23">в прошлую субботу</time>

<time datetime="2017-04-20">вчера</time>
```

Браузер отображает только содержимое тега, а содержимое datetime не отображается.

### Акцентирование внимания
Теги `<em>` и `<i>`. Названия образованы от слов «emphasis» и «italic». Предназначены для акцентирования внимания на слово или фразу. Визуально оба тега одинаковы, они выделяют текст курсивом.

Тег `<em>` определяет текст, на который сделан особый акцент, меняющий смысл предложения.

Я <em>просто обожаю</em> холодные зимние дни!

Тег `<i>` применяется для обозначения текста, который отличается от окружающего текста, но не является более важным. Например, в <i> можно заключать названия, термины, иностранные слова. Также в этот тег можно обернуть мысли героя. В речи такой текст обычно выделяется интонационно:

Он взглянул в окно и подумал — <i>такого просто не может быть</i>!

### Выделение и придание важности
Теги `<strong>` и `<b>`. Название `<b>` образовано от слова «bold». Отображаются оба тега одинаково, они выделяют текст жирным.

Тег `<strong>` указывает на важность отмеченного текста. Он может использоваться для выделения предупреждений или части документа, которую пользователь должен увидеть раньше остального. При этом обозначение части текста тегом `<strong>` не должно изменять смысла предложения.

```html
<strong>Внимание!</strong> Это место опасно. <strong>Вы можете упасть в пропасть</strong>, если подойдёте близко к краю.
Тег <b> предназначен для выделения текста с целью привлечения к нему внимания, но без придания ему особой важности. Использовать его нужно только в случае, когда остальные теги выделения не подходят. Типичный пример — выделение вводного предложения статьи.
```

```html
Вы входите в небольшую комнату. Ваш <b>меч</b> загорается ярче. <b>Крыса</b> стремительно пробегает вдоль стены.
```


### Описание изменений
Теги `<del>` и `<ins>`. Названия тегов образованы от слов «delete» и «insert». Предназначены для описания изменений в документе.

Тег `<del>` выделяет текст, который был удалён в новой версии документа. В браузере этот текст перечёркивается.

Тег `<ins>` выделяет текст, который был добавлен в новой версии документа. В браузере этот текст подчёркивается.

```html
<ul>
  <li>Почистить посудомоечную машину</li>
  <li><del datetime="2009-10-11T01:25-07:00">Погулять</del></li>
  <li><del datetime="2009-10-10T23:38-07:00">Поспать</del></li>
  <li><ins>Купить принтер</ins></li>
</ul>
```


### Разделение контента
Теги `<div>` и `<span>`. Это «чистые» элементы, и обычно они отлично подходят в качестве обёртки для стилизации или группировки других элементов. Использовать эти теги рекомендуется в тех случаях, если более подходящих семантических тегов не нашлось.

Тег `<div>` используется для группировки структурных элементов или в качестве вспомогательных контейнеров для создания нужной раскладки.

Тег `<span>` используется для группировки текстовых элементов, выделения отдельных слов или фраз внутри абзацев, пунктов списка и так далее.

```html
<article>
  <div class="highlight">
    <p>…</p>
    <p>…</p>
  </div>
  <p>Текст, в котором <span>выделена фраза</span></p>
</article>
```

# «Ссылки и изображения»

## Ссылки
### Что такое ссылка
Типичная ссылка представляет собой участок текста, щёлкая на который, вы переходите на другую страницу, открываете изображение, начинаете скачивать файл или перемещаетесь к какому-то месту на текущей странице.

Ссылки создаются с помощью тега `<a>`. Например:

```html
<a href="https://htmlacademy.ru">HTML Academy</a>
```

Тег `<a>` можно использовать вообще без адреса, то есть без атрибута href. Такой тег обозначает «ссылку-заглушку», которая в других условиях может стать обычной ссылкой. Часто ссылки-заглушки используют, чтобы показать, что мы находимся на текущей странице:

```html
<ul>
  <li><a>1 страница</a></li>
  <li><a href="2">2 страница</a></li>
  <li><a href="3">3 страница</a></li>
</ul>
```

Когда мы удаляем атрибут href у ссылки, то лучше оставить подсказку о том, почему мы это сделали. Подсказку можно добавить с помощью атрибута title. Подсказка появится, когда курсор задержится над ссылкой некоторое время.

1 страница
2 страница
3 страница

### Абсолютные ссылки
Если нужно сделать ссылку на другой сайт в интернете, то необходимо использовать «обычный» адрес. Этот «обычный» или полный адрес называется абсолютным. Выглядит он, например, так:

```html
https://site.ru/blog/index.html
```

Абсолютные адреса содержат минимум три части: протокол, имя сервера и путь.

### Относительные ссылки
Когда файл по ссылке должен открываться локально на компьютере, используются относительные адреса. В отличие от «обычных» адресов, в нём нет адреса сайта. Например:

`day-2.html`
Относительные адреса работают не только для файлов на компьютере, но и для страниц в сети. Если выложить два каких-то файла в интернет (не меняя их взаимное расположение), то их ссылка друг на друга всё равно будет работать.

Если в адресе нет имени сервера или протокола, то это относительный адрес.

### Ссылки на файл
По ссылкам можно не только переходить, но и скачивать файлы. Для этого необходимо просто в атрибуте href прописать ссылку на этот файл. А для того чтобы предотвратить открытие файлов прямо в браузере, у тега `<a>` существует атрибут download.

```html
<a href="file.pdf" download>Браузер скачает меня, а не будет читать</a>
```

### Ссылки-якоря
Ссылка-якорь — это обычная ссылка, в адресе которой используется символ #, после которого следует идентификатор элемента. Идентификатор создаётся с помощью атрибута id у того тега, к которому надо перейти при щелчке по ссылке.

```html
<a href="#part1">Глава 1</a>
```

Ссылка-якорь используется для прокрутки к заданной части страницы, в том числе используется и в абсолютных адресах.

Изображения
Подключение изображений
Для подключения изображений существует тег `<img>`, для него не требуется закрывающего тега, а путь к картинке задаётся в атрибуте src. Например:

```html
<img src="logo.png">
```


### Форматы изображений
Существует несколько основных форматов изображений: `JPEG`, `PNG`, `SVG` и `GIF`.

Формат `SVG` переводится как масштабируемая векторная графика. Качество таких изображений не меняется при изменении размеров, да и вес у них небольшой. Отлично подходит для малоцветных схем, логотипов и иконок. Чаще всего используется в случаях, когда необходимо масштабировать изображение без потерь, изменять цвет элементов изображения, анимировать части изображения.

Формат `JPEG` подходит для фотографий, рисунков с большим количеством разноцветных деталей, изображений с плавным переходом яркости и контраста. При сжатии изображения ухудшается его качество.

Формат `PNG` позволяет сохранять изображения, в которых требуется особенная чёткость. Главная особенность этого формата — поддержка прозрачности. Подходит для изображений с прозрачностью и полупрозрачностью, когда необходима повышенная точность полноцветных изображений и для изображений с резкими переходами цветов.

Формат `GIF` используется для простейших анимаций. В последнее время GIF-изображения становятся всё менее используемыми и заменяются на другие, более оптимальные форматы.

### Размеры изображения
Для управления шириной или высотой изображения, используются атрибуты width и height. Размеры в этих атрибутах задаются без единиц измерения.

```html
<img src="logo.png" width="200" height="100">
```

Если задать только один из размеров, ширину или высоту, то вторую размерность браузер вычислит самостоятельно исходя из пропорций изображения. Если задать картинке одновременно и высоту, и ширину, то браузер может нарушить пропорции исходного изображения.

### Атрибут alt
В случаях, когда картинка не может отобразиться, для того, чтобы было понятно, что на ней изображено, существует альтернативный текст. Также альтернативный текст помогает сайтам оставаться доступными, например, для категории пользователей, которая не имеет возможности видеть картинки.

Альтернативный текст изображения задаётся с помощью атрибута alt. Например:

```html
<img src="cat.png" alt="Кот, который гуляет сам по себе">
```

### Figure и figcaption
Тег `<figure>` подходит для любого иллюстративного или демонстрационного материала, которым можно дополнить содержание документа: схемы, графики, примеры кода, таблицы и так далее. При удалении такого материала основное содержание не должно пострадать, иначе это не дополнительный материал и тег `<figure>` не подходит для его разметки.

Для разъясняющего комментария к такому иллюстративному материалу существует тег `<figcaption>`, который размещается первым или последним элементом внутри `<figure>`. Например:

```html
<figure>
  <img src="image.jpg" alt="Альтернативный текст">
  <figcaption>Подпись к содержимому</figcaption>
</figure>
```

### Изображение-ссылка
Ссылки можно делать не только с помощью текста, но и с помощью изображений. Для этого нужно обернуть тег `<img>` в тег `<a>`. Например:

```html
<a href="http://keksby.ru">
  <img src="cat.png" alt="Кекс">
</a>
```

# Основы CSS
### CSS-правила
`CSS` — это язык для оформления структурированных документов, например, HTML- документов. Синтаксис — это плоский список CSS-правил. CSS-правило состоит из селектора и перечня свойств и их значений:

```css
селектор {
  свойство: значение;
  свойство: значение;
}
```

Для комментариев в CSS используются символы `/*` и `*/`.

### Селекторы
Селектор находится в начале CSS-правила, до фигурных скобок, и определяет, к каким HTML-элементам применятся свойства и значения из правила.

```css
.feature-kitten {
  padding-top: 60px;
}
```

Простейшие (и самые популярные) селекторы — это селекторы по тегам и по классам. Селекторы по тегам содержат имя тега без символов < и > и применяются ко всем подходящим тегам. Селекторы по классам начинаются с точки, за которой идёт имя класса, и применяются ко всем тегам с подходящим атрибутом class.

```css
h1 { color: red; }
.info { color: blue; }
```

На странице может быть несколько списков, и стили применятся ко всем спискам, даже к тем, которые вы менять не хотели. Чтобы избежать таких ситуаций, лучше не использовать селекторы по тегам или использовать их как можно реже.

Если у CSS-правил отличаются только селекторы, а свойства и значения одинаковые, то их можно сгруппировать через запятую.

Также можно комбинировать любые типы селекторов через пробел. Такие селекторы называются вложенными или контекстными и читаются справа налево. Например:

```css
nav a {…}
.menu ul {…}
.post .title {…}
```

### Свойства и значения
Список свойств и значений находится внутри фигурных скобок CSS-правила. Свойство определяет, какую характеристику внешнего вида мы хотим изменить, а значение — как именно.

```css
.feature-kitten {
  padding-top: 60px;
}
```

Каждый раз, когда мы добавляем новое свойство или изменяем его значение, мы меняем что-то на странице.

### Наследование
Наследование в CSS — это механизм, с помощью которого значения свойств элемента-родителя передаются его элементам-потомкам. Стили, присвоенные одному элементу, наследуются всеми потомками (вложенными элементами), но только в том случае, если они где-то явно не переопределены.

### Наследуемые свойства

На самом деле не все свойства в CSS наследуются. К наследуемым относятся в основном свойства, определяющие параметры отображения текста:

```html
font-size, font-family, font-style, font-weight, color, text-align, text-transform, text-indent, line-height, letter-spacing, word-spacing, white-space, direction и другие
```

Также к наследуемым свойствам относятся `list-style`, `cursor`, `visibility`, `border-collapse` и некоторые другие. Но они используются значительно реже.

Наследуемые свойства можно и нужно задавать через предков, следуя структуре документа.

Например, параметры текста зачастую не меняются в пределах крупных блоков страницы: меню, основного содержания, информационных панелей. Поэтому общие параметры текста (цвет, размер, гарнитура) обычно указывают в стилях этих крупных блоков.

### Не наследуемые свойства

Основные ненаследуемые свойства — это параметры позиционирования, размеров, отступов, фона, рамок:

```html
background, border, padding, margin, width, height, position и другие.
```

### Составные свойства
В CSS есть обычные свойства, управляющие одним параметром отображения, и есть составные свойства, управляющие одновременно несколькими параметрами. Например, свойство font. Оно задаёт сразу шесть параметров: размер и название шрифта, высоту строки и некоторые другие.

```css
font: 16px/26px "Arial", sans-serif;
```

Если значение обычного свойства не было задано в составном, то браузер при «расшифровке» использует исходное значение этого свойства.

### Типы значений: абсолютные и относительные
Абсолютные единицы измерения привязаны к настоящим физическим размерам и связаны между собой жёсткими пропорциями. Пиксели, px, используют чаще всего, остальные абсолютные единицы почти не применяют. Примеры абсолютных единиц измерения:

```css
font-size: 1cm;
font-size: 10mm;
font-size: 38px;
```

Относительные единицы измерения описывают значения, которые зависят от других значений. Например, ширина элемента в процентах зависит от ширины родительского элемента, а ширина элемента в em зависит от размера шрифта самого элемента. К относительным единицам относятся em, rem, vh, vw и некоторые другие, ну и, конечно же, проценты.

### Стили по умолчанию
Некоторым элементам можно не задавать никаких стилей, но у них всё равно будет какое-то оформление. Например, у списка `<ul>` есть отступы и маркеры. Такие стили называются стилями по умолчанию и задаются внутри браузерных стилей изначально. Их можно переопределить или сбросить, задав другие значения свойств элементу.

### Каскадирование
Когда браузер отрисовывает страницу, он должен определить итоговый вид каждого HTML-элемента. Для этого он собирает все CSS-правила, которые относятся к каждому элементу, ведь на элемент могут влиять сразу несколько CSS-правил. Механизм комбинирования стилей из разных источников в итоговый набор свойств и значений для каждого тега называется каскадностью. Например, есть такой элемент в разметке:

```html
<p class="beloved-color">Зелёный - мой любимый цвет</p>
```

Заданные стили:

```css
.beloved-color { color: green; }
Браузерные стили:

margin: 1em 0;
Итоговые стили:

color: green;
margin: 1em 0;
```

### Конфликт свойств
На один элемент могут действовать несколько CSS-правил. Если в этих правилах есть одинаковые свойства с разными значениями, то возникает конфликт. Например:

```css
ul { list-style: disc; }
.blog-navigation ul { list-style: none; }
```

Браузеру нужно как-то решать, какими будут итоговые значения конфликтующих свойств. Конфликт разрешается максимум за три шага. Если на текущем шаге определиться не удалось, то выполняется следующий шаг. Вот эти шаги:

Сравниваются приоритеты стилевых файлов, в которых находятся конфликтующие свойства. Например, авторские (то есть наши) стили приоритетнее браузерных.
Сравнивается специфичность селекторов у CSS-правил с конфликтующими свойствами. Например, селектор по классу более специфичен, чем селектор по тегу.
Побеждает то свойство, которое находится ниже в коде.
Каскад работает и внутри CSS-правил.

### Встраивание и подключение внешних стилей
Внешние стили подключаются через тег `<link>`

```html
<link rel="stylesheet" href="style.css">
```

Встраивание стилей в тег `<style>`. Его обычно размещают внутри `<head>`:

```html
<head>
  <style>
    CSS-код
  </style>
</head>
```

Такой способ используется для оптимизации загрузки страницы, ведь в таком случае браузер не будет отправлять дополнительных запросов на сервер.

Встраивание в атрибут style:

```html
<div style="width: 50%;"></div>
```

Свойства и значения, прописанные таким образом, применятся точечно к одному элементу.

Обычно использование этого способа считается плохой практикой. Но иногда в виде исключения бывает удобнее воспользоваться встраиванием стилей в атрибут style, чем писать отдельные CSS-правила. Например, когда нужно управлять стилями именно из разметки, и создавать отдельные классы при этом будет излишне. Так бывает, когда какие-то стилевые параметры устанавливаются с помощью сторонних программ или другими людьми, например, через CMS.








# «Оформление текста»
### Свойство font-size
Управляет размером шрифта. Значение свойства задаёт желаемую высоту символа шрифта. Причём единицы измерения могут быть абсолютными или относительными.

Самая часто используемая единица измерения размера шрифта — пиксели px:

```css
p {
  font-size: 20px;
}
```

Но, чтобы при изменении основного размера шрифта родителя его дочерние элементы пропорционально меняли свои размеры шрифта, есть специальная единица измерения — em.

Величина 1em — это такой же размер шрифта, что и у родителя. Соответственно, если нужно, чтобы шрифт дочернего элемента был всегда в 2 раза больше родительского, то надо задать значение 2em:

```css
h1 {
  font-size: 2em;
}
```

### Свойство line-height
Свойство управляет высотой строки или межстрочным интервалом.

По умолчанию это свойство имеет значение normal. Оно указывает браузеру, что межстрочный интервал нужно подобрать автоматически, исходя из размера шрифта. Спецификация рекомендует устанавливать его в пределах 100-120% от размера шрифта. То есть:

```css
p {
  font-size: 10px;
  line-height: normal; /* значение будет примерно 12px */
}
```

Значение normal позволяет всем нестилизованным текстам выглядеть удобочитаемо. Однако, если есть необходимость отойти от стилизации по умолчанию, line-height можно задать фиксированное абсолютное значение в px.

```css
p {
  font-size: 16px;
  line-height: 26px;
}
```

Если нужно задать line-height относительное значение, но не такое, как normal, то значение задаётся в процентах или в виде множителя. В таком случае браузер вычисляет значение динамически в зависимости от font-size:

```css
p {
  font-size: 10px;
  line-height: 150%; /* вычисленное значение: 10px * 150% = 15px */
  line-height: 2;    /* вычисленное значение: 10px * 2 = 20px */
}
```

Относительные значения более гибкие, чем абсолютные. Но для простых сайтов фиксированных font-size и line-height будет вполне достаточно.

### Свойство font-family
В значении этого свойства указывается список названий шрифтов, перечисленных через запятую. В начале списка располагают самый желаемый шрифт, затем менее желаемый, а в самом конце списка — общий тип шрифта. Браузер проходит по списку слева направо и использует первый найденный в системе или на сайте шрифт. Если название шрифта состоит из нескольких слов, то его нужно заключать в кавычки.

```css
body {
  font-family: "PT Sans", "Arial", sans-serif;
}
```

### Свойство font-weight
Свойство задаёт насыщенность или толщину шрифта. Шрифт может быть жирнее или тоньше обычного начертания. В качестве значения можно использовать ключевое слово или число. Самые часто встречающиеся значения:

400 или normal — обычный шрифт, значение по умолчанию;

700 или bold — жирный шрифт.

Например:

```css
h1 {
  font-weight: 400; /* то же самое что и normal */
}

p {
  font-weight: bold; /* то же самое что и 700 */
}
```

### Свойство text-align
Описывает, как выравнивается текст и другие инлайновые элементы (изображения, инлайн-блоки, инлайн-таблицы и другие) внутри блока по горизонтали.

Свойство может принимать следующие значения:

```css
left — выравнивание по левому краю блока, это значение по умолчанию;
right — по правому краю блока;
center — по центру блока;
justify — по ширине блока, при этом слова в строке будут размещаться так, чтобы занять равномерно всё пространство строки (пробелы между словами в таком случае становятся неравномерными, так как браузер «растягивает» слова в строке).
```

Важно помнить, что свойство text-align применяется именно к самому блоку-контейнеру, внутри которого находится текстовый контент:

HTML:
```html
<p>
  Я текст внутри абзаца
</p>
```

CSS:
```css
p {
  text-align: center;
}
```

### Свойство vertical-align
Свойством можно выравнивать инлайновые элементы относительно содержащей его строки. Самый простой пример — выровнять картинку <img> по вертикали в текстовой строке.

У свойства vertical-align много значений, но самые часто используемые:

```css
top — выравнивание по верхнему краю строки;
middle — по середине строки;
bottom — по нижнему краю строки;
baseline — по базовой линии строки (значение по умолчанию).
```

В отличие от text-align свойство vertical-align задаётся самому элементу, а не содержащему его контейнеру:

HTML:
```html
<p>
  <img src="picture.png" alt="Я картинка">
  Я текст внутри абзаца
</p>
```
CSS:
```css
img {
  vertical-align: middle;
}
```

### Свойство color
Цветом текста можно управлять свойством color.

Цвет может быть задан в виде ключевого слова (полный список ключевых слов приводится в спецификации). Например:

```css
color: black; /* чёрный цвет */
color: red;   /* красный цвет */
color: white; /* белый цвет */
```

Ещё один вариант указания цвета — в виде шестнадцатеричного значения. В этом случае цвет формируется из красной, зелёной и синей составляющих, заданных в виде шестнадцатеричного числа от 00 до ff. Помимо шести, цветовой код может содержать три знака, в этом случае второй символ в цветовых составляющих дублируется первым:

```css
color: #000000; /* чёрный цвет */
color: #f00;    /* красный цвет, то же что #ff0000 */
color: #fff;    /* белый цвет, то же что #ffffff */
```

Если не хочется иметь дело с шестнадцатеричными значениями, можно воспользоваться специальной функцией rgb, в которой указывается цвет в более привычном десятичном виде в диапазоне от 0 до 255 также в виде трёх цветовых составляющих, перечисленных через запятую:

```css
color: rgb(0, 0, 0)       /* чёрный, то же что #000000 */
color: rgb(255, 0, 0)     /* красный, то же что #ff0000 */
color: rgb(255, 255, 255) /* белый, то же что #ffffff */
```
У функции rgb есть расширенная версия — rgba. В этом случае помимо указания цвета последним значением указывается степень непрозрачности цвета — alpha. Значение может быть от 0 (полностью прозрачный) до 1 (полностью непрозрачный):

```css
color: rgba(0, 0, 0, 0.5)      /* чёрный, непрозрачный на 50% */
color: rgba(255, 0, 0, 0.3)     /* красный, непрозрачный на 30% */
color: rgba(255, 255, 255, 0.9) /* белый, непрозрачный на 90% */
```


### Контраст цвета текста и фона
Фоновое изображение и фоновый цвет блока всегда должен достаточно сильно контрастировать с цветом текста в этом блоке. Чем больше контраст, тем удобнее этот текст читать в разных условиях освещённости и на разных устройствах. Поэтому если вы задаёте блоку фоновое изображение, нужно обязательно дополнительно задавать подходящий фоновый цвет. В этом случае, пока изображение загружается, или в случае, если оно совсем не загрузится, текст всё равно можно будет прочитать:

```html
p {
  /* идеальный контраст: цвет текста белый, цвет фона — чёрный */
  background-color: #000000;
  color: #ffffff;
}

span {
  /* плохой контраст: цвет текста и фона — серые */
  background-color: #cccccc;
  color: #dddddd;
}
```

### Свойство white-space, управление пробелами
Браузер игнорирует множественные пробелы и переносы строк в HTML-коде. С помощью свойства white-space можно управлять пробелами и переносами строк. Свойство принимает значения:

nowrap — схлопывает лишние пробелы и отображает весь текст одной строкой без переносов;
pre — сохраняет пробелы и переносы как в исходном коде аналогично тегу `<pre>`;
pre-wrap — работает как значение pre, но добавляет автоматические переносы, если текст не помещается в контейнер;
normal — режим по умолчанию: лишние пробелы и переносы строк схлопываются, текст переносится, пробелы в конце строк удаляются.

### Свойство text-decoration

Задаёт дополнительное оформление текста. Значения свойства:

```css
underline — подчёркивание;
line-through — зачёркивание;
overline — надчёркивание;
none — убирает вышеперечисленные эффекты.
```

К тексту можно одновременно применить несколько эффектов, если перечислить значения через пробел:

```html
p {
  text-decoration: underline; /* подчёркнутый текст */
}

span {
  /* подчёркнутый и зачёркнутый текст */
  text-decoration: underline line-through;
}
```

### Свойство text-decoration — составное. Оно раскладывается на отдельные свойства:

```css
text-decoration-line — вид линии: зачёркивание, подчёркивание или надчёркивание;
text-decoration-style — стиль линии, может принимать значения:
solid — сплошная линия;
double — двойная линия;
dotted — точечная линия;
dashed — пунктирная линия;
wavy — волнистая линия.
text-decoration-color — цвет линии.
```

### Свойство font-style
Свойством можно задать начертание текста. Его основные значения:

```css
normal — обычное начертание;
italic — курсивное начертание;
oblique — наклонное начертание.
```

Если задано значение italic, браузер будет пытаться найти в заданном шрифте отдельное курсивное начертание символов. В некоторых шрифтах отдельный курсив предусмотрен.

Если отдельного курсивного начертания в шрифте не предусмотрено, то браузер сделает текст наклонным, то есть сымитирует курсив. Что равноценно заданию тексту значения font-style: oblique.

### Свойство text-transform
С его помощью можно управлять регистром символов: делать буквы строчными (маленькими) или заглавными (большими). Значения свойства:

```css
lowercase — все строчные;
uppercase — все заглавные;
capitalize — каждое слово начинается с большой буквы;
none — отменяет изменение регистра.
```

### Отступы
Важный фактор того, что текст в блоке будет удобочитаемым, это наличие свободного пространства в блоке для этого текста. Вокруг текста должно быть достаточно «воздуха», он не должен «прилипать» к краям, ему не должно быть «тесно».

За отступы в CSS отвечают два свойства: padding задаёт внутренние отступы в блоке, а margin задаёт внешние отступы.




# Возможности HTML и CSS

### Теги header и footer, хедер и футер

Начнём с «шапки» и «подвала» сайта. Разметим их тегами `<header>` и `<footer>`.

```html
<header> — хедер сайта или раздела;
<footer> — футер сайта или раздела.
```

Хедер — это не только привычная шапка сайта с логотипом и меню, он может использоваться и как «шапка» какой-нибудь статьи или раздела сайта. Конечно, в этом случае хедер называют не «шапкой», а вводной частью, в которой могут содержаться заголовки, оглавление и так далее.

С футером ситуация аналогичная. В привычном нам понимании это «подвал» сайта, с копирайтами, контактной информацией и так далее. Но футер может
использоваться и в других разделах сайта. Например, в футере статьи можно разместить дополнительную информацию: данные об авторе, дополнительные ссылки и так далее.

А раз теги не уникальные, то и стилизовать их лучше с помощью классов, как мы и сделали.

Если вы не хотите использовать классы для шапки и подвала сайта, то можете использовать селекторы body > header и body > footer. Эти селекторы не повлияют на хедеры и футеры, вложенные более глубоко.

### Тег main, основное содержание

Если вы не хотите использовать классы для шапки и подвала сайта, то можете использовать селекторы body > header и body > footer. Эти селекторы не повлияют на хедеры и футеры, вложенные более глубоко.

### Теги article и section, разделы страницы

Разметим разделы «Обо мне» и «Последние посты». Используем для этого теги `<section>` и `<article>`:

```html
<section> — смысловой или логический раздел документа;
<article> — самостоятельный и независимый раздел документа
```

Чтобы не было путаницы, разберём где и когда использовать разные контейнеры:

●	`<div>` — контейнер общего назначения, не обязательно смысловой. Дивы используются для разметки мелких блоков, создания сетки и декоративных эффектов.
●	`<section>` — более крупный логический контейнер, объединяющий содержание по смыслу. Например, блок «О компании», список товаров, раздел личной информации в профиле и так далее.
●	`<article>` — самостоятельный, цельный и независимый раздел документа. Этот раздел можно в неизменном виде использовать в различных местах, в том числе и на других сайтах. Примеры: статья, пост в блоге, сообщение на форуме и так далее.

### Теги h1-h6, заголовки разделов страницы

Как правило, в разделы `<section>` и `<article>` включают заголовки, резюмирующие содержимое разделов.

Всего может быть шесть уровней заголовков. Размечаются они тегами `<h1>`, `<h2>` … `<h6>`. А как правильно определить нужный уровень заголовков?
При озаглавливании разделов учитывается общая иерархия текстового содержимого страницы: сначала определяется, о чём эта страница целиком, какие разделы документа более крупные, какие — дополнительные. В итоге заголовки должны из себя представлять явное дерево: от главного `<h1>` на странице до структурно следующих за ним `<h2>`, `<h3>` и так далее.

```html
h1 — Интернет-магазин зоотоваров «Усы, лапы и хвост»
h2 — Список товаров
h2 — Похожие предложения
h3 — Когтеточка «Росомаха»
h3 — Палка с пером «Шерстяной охотник»
```

Если в дизайне страницы у раздела не предусмотрен заголовок, его всё равно следует добавлять в разметку. При этом с помощью стилей заголовки можно «визуально спрятать», но оставить доступным их содержимое

### Тег nav, основная навигация

в HTML есть специальный элемент для навигационных блоков — тег `<nav>`. Так что меню и блоки ссылок лучше оборачивать не в дивы, а в навы.

В случае, когда навигация шапки дублируется в подвале сайта, не рекомендуется использовать тег `<nav>` повторно. Достаточно будет использовать список со ссылками.

### правило @font-face

Технически подключение веб-шрифтов производится с помощью CSS-правила @font-face. Читается как «эт-правило font-face». Вот пример:

```css
@font-face {
  font-family: "Roboto";
  src:
    local("Roboto Regular"),
    url("roboto.woff") format("woff");
}
```

В этом правиле вы указываете название шрифта, которое будете использовать в font-family и источники, из которых браузер сможет загрузить шрифт. Обычно сначала указывают название шрифта в системе, чтобы браузер попытался найти его локально на компьютере пользователя, а затем указывают адрес файла шрифта в интернете.

Получается, что можно хранить шрифты и подключать их со своего сервера. Это особенно полезно, когда шрифт очень редкий и его нет ни в одном из шрифтовых сервисов. В этом случае поступают так:

1.	Берут файл шрифта (например, .ttf) и конвертируют в веб-формат в сервисе наподобие Font Squirrel (для кириллических шрифтов надо указать дополнительные параметры конвертации).
2.	Затем сконвертированные файлы шрифта размещают у себя на сервере.
3.	И подключают шрифт с помощью @font-face

### Тег aside, дополнительное содержание

Этот раздел состоит из двух частей. В первой части будет содержаться основная информация, а во второй вспомогательная. Поэтому основную часть мы разметим с помощью уже знакомого `<section>`. А вторую часть разметим с помощью тега `<aside>`.
`<aside>` — это дополнительное содержание, не связанное напрямую с основным. Ещё такие блоки часто называют «сайдбарами» или боковыми панелями.

### article: анонс поста

Пост — это цельный, законченный и самостоятельный фрагмент информации. Для его разметки идеально подойдёт тег `<article>`.
Так как `<article>` должен быть независимым, то при разметке удобно считать его отдельной и самостоятельной страницей сайта. При этом иерархия заголовков на всей нашей странице должна быть «сквозная», то есть внутри `<article>` заголовок будет «очередного» уровня. Заголовок родительского раздела `<section>` у нас второго уровня — h2, значит внутри `<article>` нужен заголовок третьего уровня — h3.

### Тег time, дата и время для людей и машин

В HTML есть специальный тег для обозначения даты и времени — `<time>`. С помощью `<time>` можно описывать даты одновременно и для человека, и для машины, например:

```html
<time datetime="2014-04-20">Вчера</time> мы готовили курс к публикации.
```

Браузер отображает только содержимое тега, а содержимое datetime не отображается. Человек увидит только слово «вчера», а машина прочитает атрибут и получит дату в нужном ей формате. И все довольны.

### Теги figure и figcaption, картинки с подписями

начнём с фотопоста.
Для его разметки используем тег `<figure>` — он обозначает цельный и независимый блок содержания. Внутри этого тега размещают демонстрационный материал: изображения, схемы, куски кода и так далее.

Обычно каждый такой материал сопровождает разъясняющий комментарий или «легенда». Для обозначения этого комментария и предназначен ещё один новый тег — `<figcaption>`, который размещается первым или последним элементом внутри `<figure>`. Пример:

```html
<figure>
  схема,
  график,
  диаграмма
  и так далее
  <figcaption>Легенда</figcaption>
</figure>
```

### Тег video, видео

В HTML с самого начала было очень просто вставлять изображения, но очень сложно видео и аудио. Сейчас эта проблема решена.
Для вставки видео предназначен специальный парный тег `<video>`. Его основные атрибуты:

width и height	задают ширину и высоту видео
controls	пустой атрибут, при наличии которого отображается панель управления видео
preload	задаёт режим предзагрузки видео, имеет 3 возможных значения:
●	none — не загружать ничего;
●	metadata — загрузить служебную мета-информацию (длительность, первый кадр и так далее);
●	auto — можно загрузить всё видео.
значение по умолчанию зависит от браузера
src	задаёт адрес видеофайла
autoplay	пустой атрибут, при наличии которого воспроизведение видео начинается автоматически
poster	задаёт адрес картинки-обложки, которая отображается, когда видео ещё не загрузилось или не воспроизводится

### Форматы и источники видео

У тега `<video>` есть атрибут src, в котором можно указать адрес видеофайла, но мы почему-то его не использовали.
Всё дело в том, что в текущий момент существует несколько форматов видео, каждый из которых хорошо поддерживается лишь некоторыми браузерами. Вот три самых распространённых формата и их поддержка:

●	MPEG-4/H.264
●	OGG/Theora
●	WebM

Поэтому мы должны в видео указывать адреса файлов во всех этих форматах (и конвертировать исходное видео в эти форматы, конечно). Делается это с помощью тегов `<source>`:

```html
<video controls>
  <source src="video.mp4" type="video/mp4">
  <source src="video.ogv" type="video/ogg">
  <source src="video.webm" type="video/webm">
</video>
```

В атрибуте src указывается адрес видеофайла, а в атрибуте type его тип (также там могут указываться и кодеки). Браузер из списка видеофайлов выбирает первый, который может проиграть и загружает его.
Атрибут type не является обязательным, так как браузер умеет сам определять тип и кодеки, но указывая тип явно, мы помогаем ему не ошибиться.

### Тег audio, аудио

Работа с аудио в HTML очень похожа на работу с видео, только у тега для аудио чуть меньше параметров.
Для вставки звука предназначен тег `<audio>`. Его основные атрибуты:

controls	пустой атрибут, при наличии которого отображается панель управления проигрывателем
preload	задаёт режим предзагрузки аудио, имеет 3 возможных значения:
●	none — не загружать ничего;
●	metadata — загрузить служебную мета-информацию;
●	auto — можно загрузить весь файл.
значение по умолчанию зависит от браузера
src	задаёт адрес аудиофайла
autoplay	пустой атрибут, при наличии которого воспроизведение звука начинается автоматически

### Форматы и источники звука

У звуковых файлов с поддержкой форматов дела обстоят лучше, чем у видео.
Для охвата большинства современных браузеров, достаточно использовать всего два формата:

●	MP3
●	OGG

И снова мы не можем указать только один файл в атрибуте src у тега `<audio>`. Мы должны так же, как и в случае с видео, перечислить адреса звуковых файлов в разных форматах с помощью тегов `<source>`:

```html
<audio controls>
  <source src="sound.mp3" type="audio/mpeg">
  <source src="sound.oga" type="audio/ogg">
</audio>
```

Теги `<source>` в аудио работают так же, как и в видео.





## Знакомство с таблицами

### Простейшая таблица

Из всех объектов, которые используются для разметки текста в интернете, таблицы являются самыми сложными для новичков. Действительно, табличные данные приходится публиковать достаточно часто. В отличие от списков, абзацев, заголовков и изображений, с таблицами всегда возникает море проблем.
В этом курсе мы узнаем, как с помощью HTML описывать таблицы, научимся делать простые и достаточно сложные таблицы. И, самое главное, научимся аккуратно оформлять таблицы с помощью CSS. Вы увидите, как на самом деле легко и просто работать с таблицами.
Начнём с самого простого. Уберите комментарий в коде редактора и посмотрите на простейшую таблицу из четырёх строк и двух колонок.

### Добавляем строки

Простейшая таблица описывается с помощью трёх тегов:

```html
1.	<table> обозначает таблицу.
2.	<tr> расшифровывается как «table row», обозначает строку таблицы.
3.	<td> расшифровывается как «table data», обозначает ячейку внутри строки таблицы.
```

Теги `<td>` располагаются внутри тегов `<tr>`, а те, в свою очередь, внутри `<table>`. Почти всё текстовое содержимое таблицы размещается внутри тегов `<td>`.

В простейшей таблице в каждой строке должно быть одинаковое количество ячеек, то есть внутри всех `<tr>` должно быть одинаковое количество `<td>`.

### Добавляем столбцы

Для того чтобы добавить столбец в таблицу, надо в каждую строку `<tr>` добавить по ячейке `<td>`.

### Задаём рамки с помощью CSS

Таблицы в предыдущих заданиях отображались с рамками по умолчанию. Такие рамки отображаются, если у тега `<table>` задан атрибут border с ненулевым значением.
Но с помощью атрибута border гибко управлять рамками не получается. С его помощью можно только изменять их толщину.
Поэтому мы будем учиться использовать CSS. С помощью CSS-свойства border можно задавать как внешние рамки таблицы, так и рамки каждой ячейки.

### border-collapse

Чтобы избавиться от таких двойных рамок, используется CSS-свойство таблицы border-collapse. Вот так:

```html
table {
  border-collapse: collapse;
}
```

Значение collapse убирает двойные рамки: cхлопываются рамки соседних ячеек, а также рамки ячеек и внешняя рамка таблицы. При этом внешняя рамка таблицы может исчезнуть, и чтобы её вернуть, можно увеличить её ширину

### Горизонтальные и вертикальные рамки

Иногда требуется, чтобы рамки ячеек в таблице отображались не полностью. Например, чтобы отображалась только нижняя рамка ячеек, тогда таблица получается расчерченной по горизонтали. Аналогично, если отображать только боковые рамки ячеек, то таблица получается разбитой на столбцы.
Такие эффекты легко достигаются с помощью CSS. Для этого необходимо использовать не свойство border, которое задаёт рамки для всех сторон ячейки, а одно из свойств:

```html
●	border-top,
●	border-right,
●	border-bottom,
●	border-left.
```

Эти свойства задают отображение только одной рамки ячейки: верхней, правой, нижней или левой соответственно.

### Отступы внутри ячеек

Отступы между ячейками можно задать:

●	с помощью атрибута cellspacing тега `<table>`
●	или c помощью CSS-свойства border-spacing.

Отметим, что свойство border-spacing задаётся для таблицы, в отличие от padding, которое задаётся для ячеек.

### Ячейки-заголовки

Обычно в таблицах выделяют названия столбцов или строк. В HTML для этого предусмотрен специальный тег `<th>`, который расшифровывается как «table header» и обозначает ячейку-заголовок. Тег `<th>` аналогичен `<td>`, он так же должен располагаться внутри `<tr>`, для него стилями можно задавать все те же свойства.
По умолчанию текст внутри `<th>` выделяется жирным и выравнивается по центру ячейки.

### Заголовок таблицы

Сейчас подпись Распределение браузеров сделана с помощью заголовка первого уровня. В принципе, можно догадаться, что это название таблицы, но семантически правильнее будет сделать это название с помощью тега `<caption>`.

Тег `<caption>` должен размещаться внутри тега `<table>`, причём непосредственно внутри него и первым, до остальных вложенных тегов. Вот так:

```html
<table>
  <caption>Текст</caption>
  ...
 </table>
```

Тег заголовка идёт первым внутри таблицы, но с помощью CSS можно переместить заголовок таблицы в любое место: сверху или снизу таблицы, по центру, справа или слева.

По вертикали заголовок таблицы перемещается CSS-свойством caption-side со значениями top и bottom, которые обозначают до и после таблицы соответственно.
По горизонтали заголовок таблицы выравнивается CSS-свойством text-align со значениями left, right и center.

### Объединяем ячейки в строках

Чтобы объединить ячейки по горизонтали, необходимо использовать атрибут colspan у тегов `<th>` или `<td>`.
Когда вы задаёте ячейке атрибут colspan со значением 2, то ячейка как бы «растягивается» на ячейку справа, но та ячейка не исчезает, а отодвигается и в таблице появляется новый столбец. Чтобы удалить его, нужно удалить ячейку, которая находится справа от «растянутой».

### Объединяем ячейки в столбцах

Объединение ячеек по вертикали немного сложнее. Оно осуществляется с помощью атрибута rowspan у тега `<td>` или `<th>`.
Когда вы задаёте ячейке атрибут rowspan со значением 2, то ячейка как бы «растягивается» на следующую строку. При этом ячейка, которая была под «растянутой» отодвигается в своей же строке вправо, что добавляет в таблицу лишний столбец. Удалив ячейку, которая была под «растянутой», мы избавимся от этого столбца.

### Выравнивание содержимого в ячейках

Содержимое ячеек можно выравнивать по горизонтали и по вертикали с помощью CSS.
За выравнивание по горизонтали отвечает CSS-свойство text-align. Чаще всего используются значения left, center и right.
За выравнивание по вертикали отвечает CSS-свойство vertical-align. Чаще всего используются значения top, middle и bottom.
На самом деле, значений у обоих свойств больше, но в случае с ячейками нас интересуют только перечисленные.
Чтобы задать выравнивание содержимого ячеек, надо в стилях указать:


```html
{
  vertical-align: значение;
  text-align: значение;
}
```

### Добавим цвета

Цветами можно управлять с помощью этих свойств:

●	background-color — задаёт цвет фона,
●	color — цвет текста,
●	border-color — цвет рамок.

До этого мы использовали компактную форму для описания рамок: border: 1px solid lightgray. В этой записи цвет задаёт третья часть — lightgray.

```css
td {
  color: цвет;
  background-color: цвет;
  border: 1px solid цвет;
}
```

### Задаём размеры таблицы

С помощью CSS можно управлять размерами таблицы, задавать желаемую ширину и высоту. Также размерами можно управлять с помощью атрибутов таблицы, но мы рассмотрим только CSS.
Стоит отметить, что у таблицы есть минимальные размеры, которые зависят от содержания, меньше которых она не сожмётся, какое бы значение ширины или высоты ни задавалось.
Ширина таблицы задаётся с помощью CSS-свойства width, а высота с помощью свойства height, например:

```css
table {
  width: 100px;
  height: 100px;
}
```

Размеры таблицы можно задавать как в абсолютных единицах, например, в пикселях — 20px, так и в относительных, в процентах — 20%.
При использовании процентов размеры таблицы будут вычисляться с учётом размеров родительского элемента, в нашем случае окна мини-браузера.
Особое значение auto включает расчёт размеров по умолчанию. Например, width: auto; или height: auto;.
Важное замечание. Проценты при задании высоты обычно не работают.

### Задаём размеры отдельных ячеек и столбцов

Размеры ячеек и столбцов тоже можно задавать вручную, особенно если вам не нравится, как браузер распределил ширину колонок. Размеры ячеек задаются точно так же, как и размеры таблицы: с помощью CSS-свойств width и height.
Есть два варианта добавления стилей ячейкам:

1.	Назначать ячейкам уникальные имена классов, например, class="cell-11", и применять стили для этих классов.
2.	Использовать атрибут style, внутри которого можно писать CSS-код

Пример второго варианта:

```html
<td style="width: 100px;">
  ...
</td>
```

К счастью, редко нужно задавать размеры каждой ячейки. Обычно размеры ячеек прописывают, когда надо вручную установить ширину столбцов таблицы: для этого достаточно задать ширину для каждой ячейки из первой строки.

## Формы, часть 1

### Первая форма

Формы нужны для того, чтобы отправлять данные с веб-страницы на веб-сервер, который сможет эти данные обработать: зарегистрировать пользователя, создать сообщение на форуме, отправить письмо и так далее. В общем, формы в вебе просто необходимы.
Чтобы создать форму, нужно использовать парный тег `<form>`, внутри которого размещаются поля формы. У тега `<form>` есть два важных атрибута:

```html
●	action задаёт адрес, URL, отправки формы;
●	method задаёт метод отправки формы.
```

Пример:

```html
<form action="https://echo.htmlacademy.ru/courses" method="get">
  поля формы
</form>
```

Для отправки формы обычно используют методы get или post. Если не указать атрибут method, то будет использован get.
Метод get посылает данные формы в строке запроса, то есть они видны в адресной строке браузера и следуют после знака вопроса. Например:

```html
https://www.google.com/search?q=htmlacademy
```

Метод get лучше использовать в поисковых формах, потому что он позволяет получить ссылку на результаты поиска и передать её кому-то.
Метод post посылает данные в теле HTTP-запроса и используется, когда нужно отправить много данных и ссылка на результат обработки этих данных не нужна. Например, при редактировании личного профиля.

### Текстовое поле ввода

Большинство полей форм создаётся с помощью одиночного тега `<input>`. У этого тега два обязательных атрибута:

●	type задаёт тип поля;
●	name задаёт имя поля.


Тип поля влияет на то, как оно будет отображаться и вести себя. Самый распространённый тип — это text, который обозначает текстовое поле. Он же используется по умолчанию. Пример:

```html
<form action="https://echo.htmlacademy.ru/courses" method="get">
  <input type="text" name="search">
</form>
```

Имя поля нужно, чтобы правильно обработать данные на сервере. Обычно, имя поля должно быть уникальным в пределах формы, хотя есть исключения. Для задания имени поля используют латинские буквы и цифры.

### Идентификатор и значение по умолчанию

Атрибут id поля ввода обозначает идентификатор. Он должен быть уникальным не только в пределах формы, но и на всей странице.
Обычно идентификаторы используют для повышения удобства работы с формой, например, создают подписи, связанные с мелкими полями. При нажатии на такие подписи активируется связанное поле. И это удобно, так как по большой подписи попасть легче, чем по маленькому полю. Также идентификаторы используют в JavaScript для работы с полями.
Идентификатор, в отличие от имени поля, не передаётся на сервер. Лучше использовать идентификаторы, отличающиеся от имени поля, особенно актуально это для полей множественного выбора, которые мы разберём далее в курсе.
Атрибут value задаёт значение поля ввода по умолчанию. Это тоже повышает удобство.
Согласитесь, приятно зайти в огромную анкету на каких-нибудь госуслугах, а там ваши паспортные данные уже подставлены в нужные поля и заполнять их не надо. И всё благодаря тому, что программист добавил к полям атрибут value с нужными данными.

### Подпись для поля ввода

Можно подумать, что сделать подпись к полю очень просто. Пишем текст рядом с полем и всё готово:

```html
Подпись <input type="text" name="username">
```

На самом деле этого недостаточно — мы получили просто кусок текста и поле, которые расположены рядом друг с другом, но логически никак не связаны.
Есть специальный тег, который позволяет смело сказать: «Этот кусок текста действительно подпись к этому полю!». Это парный тег `<label>`.
Он связывает текст и поле ввода логически. А ещё если нажать на текст в такой подписи, то курсор переместится в соответствующее поле.
Создавать подписи к полям с помощью `<label>` — хороший приём. Используйте его.
Первый способ создать подпись — просто обернуть текст подписи и тег поля в тег `<label>`, вот так:

```html
<label>
  Подпись <input type="text" name="username">
</label>
```

Надо отметить, что при оборачивании текста в тег `<label>` он визуально никак не меняется, ведь главная задача подписи — создать логическую связь.

### Связываем подпись и поле по id

Иногда обернуть поле и текст подписи в тег `<label>` нельзя. Например, когда они размещены в разных ячейках таблицы.
В этом случае можно связать подпись с полем с помощью атрибута id. Алгоритм такой:

1.	Добавляем к полю ввода идентификатор с помощью атрибута id.
2.	Оборачиваем текст подписи в тег `<label>`.
3.	Добавляем тегу `<label>` атрибут for.
4.	В атрибут for записываем такое же значение, что и в атрибуте id у поля.

Например:

```html
<label for="user-field-id">Имя пользователя</label>
...
много-много других тегов
...
<input id="user-field-id" type="text" name="username">
```

### Поле для ввода пароля

Чтобы сделать его настоящим полем для ввода пароля, в котором текст будет отображаться «звёздочками», нужно просто изменить значение атрибута type на password.

### Кнопка отправки формы

Форма практически готова. Осталось добавить кнопку для отправки формы. Такая кнопка создаётся с помощью тега `<input>` c типом submit.
Надпись на кнопке можно задать с помощью атрибута value. Для кнопки отправки формы задавать имя необязательно. Но если имя задано, то на сервер будут отправляться имя и значение кнопки.

Обычно имя для кнопки отправки задают, когда в форме несколько кнопок, отвечающих за разные действия. Браузер отправляет на сервер имя и значение только той из них, на которую нажал пользователь. Таким образом, сервер может понять, какую кнопку нажали и что нужно сделать.

### Многострочное поле ввода

Мы научились создавать простейшие формы с текстовыми полями и кнопками. А теперь познакомимся с более сложными элементами формы.
Многострочное текстовое поле создаётся с помощью парного тега `<textarea>`. У него есть атрибуты name и id, которые аналогичны атрибутам текстового поля.

Атрибут rows принимает целочисленное значение и задаёт высоту многострочного поля в строках. Атрибут cols задаёт ширину поля в символах. В качестве ширины символа берётся некоторая «усреднённая ширина».
Атрибут value у многострочного поля отсутствует, а значение по умолчанию задаётся по-другому. Текст, расположенный между открывающим и закрывающим тегом `<textarea>` и является значением по умолчанию. Вот так:

```html
<textarea>Значение по умолчанию</textarea>
```

### Чекбокс

Чекбокс — это тег `<input>` с типом checkbox.
Чекбокс работает по принципу «либо да, либо нет». Если чекбокс включён, то браузер посылает переменную с именем поля на сервер, а если выключен, то не посылается ничего. Таким образом, атрибут value не является обязательным.

Чтобы сделать чекбокс включённым по умолчанию, нужно добавить к тегу атрибут `checked`. Вот так:

```html
<input type="checkbox" checked>
```

Чекбокс не подразумевает выбор одного элемента из нескольких. Поэтому если в одной форме есть несколько чекбоксов, то имена у них должны быть разными.

### Радиокнопка

Радиокнопка — это тег `<input>` с типом radio.
Обычно радиокнопки размещают группами по несколько штук. Причём у радиокнопок из одной группы должно быть одинаковое имя и разные значения, которые задаются c помощью value.

Таким образом, атрибут value является для радиокнопок обязательным. Браузер отправляет на сервер значение value выбранной радиокнопки.
В этом задании мы начнём создавать группу радиокнопок.

### Группа радиокнопок

Теперь добавим ещё один вариант ответа в нашу группу радиокнопок. Для этого нужно добавить ещё один `<input>` с таким же именем, но другим значением value.

Подобным образом можно создавать группы радиокнопок с любым количеством вариантов.

Чтобы сделать какой-либо вариант в группе выбранным по умолчанию, нужно добавить к соответствующему тегу `<input>` атрибут checked, как у чекбокса.
Кстати, имя у радиокнопок одной группы должно быть одинаковым, но идентификаторы всегда должны быть уникальными.

### Раскрывающийся список, или «селект»

Раскрывающийся список создаётся с помощью парного тега `<select>`, у которого есть знакомые атрибуты name и id.

Варианты ответов задаются с помощью парных тегов `<option>`, которые должны располагаться внутри тега `<select>`. Например:

```html
<select name="theme">
  <option value="light">Светлая тема</option>
  <option value="dark">Тёмная тема</option>
  ...
</select>
```

В атрибуте value тега `<option>` задаётся значение варианта ответа, а внутри этого тега располагается подпись варианта ответа.
Если при отправке формы у выбранного варианта задан value, то на сервер отправится значение этого атрибута. В противном случае будет отправлен текст подписи.

### «Мультиселект»

Раскрывающийся список можно превратить в так называемый «мультиселект», то есть список, в котором можно выбрать не один, а несколько вариантов.
Чтобы сделать это, нужно добавить к тегу `<select>` атрибут multiple.
Выбрать несколько вариантов можно, щёлкая по ним с зажатой клавишей Ctrl на Windows или Command на MacOS.
Высоту мультиселекта можно изменять с помощью атрибута size тега `<select>`.
Чтобы отметить как выбранные по умолчанию одно или несколько значений, нужно к соответствующим тегам `<option>` добавить атрибут selected.
При отправке данных мультиселекта на сервер с PHP после имени в значении атрибута name ставятся символы квадратных скобок []. Например,

```html
<select name="days[]">
```

 Это необязательное требование для имени мультиселекта, а нужно только для корректной обработки данных в PHP.

### Поле для загрузки файлов

Поле для загрузки файлов — это тег `<input>` с типом file. Для этого поля обязательным атрибутом является имя.
Чтобы поле заработало и браузер смог передать выбранный файл на сервер, необходимо добавить форме атрибут enctype со значением multipart/form-data. Не полю, а форме.
Этот атрибут указывает браузеру, в каком виде пересылать данные. Если вы хотите отправить на сервер файл, данные из формы эффективнее всего передавать по частям. За это и отвечает значение multipart/form-data.
Кстати, внешний вид полей с типом file очень сильно отличается в зависимости от операционной системы и очень плохо изменяется с помощью стилей.

### Скрытое поле

И ещё одно невидимое и очень полезное поле. Это скрытое поле. Его используют, когда в форме нужно отправить какие-то дополнительные служебные данные, которые не вводятся пользователем.
Например, это могут быть реквизиты заказа или номер пользователя в форме оплаты.
Скрытое поле — это тег `<input>` с типом hidden.





## Формы, часть 2

### Сброс введенных значений

Сначала разберёмся с возможностями кнопок, не рассмотренными в базовом курсе про формы.
Экспериментировать будем над формой логина в котопрофайл.
В HTML-формах есть специальная кнопка, которая сбрасывает введённые значения и возвращает изначально установленные. Это поле ввода с типом reset.
Пример использования:

```html
<input type="reset" value="Сбросить">
```

Обратите внимание, что кнопка не обнуляет значения, а возвращает те, которые были установлены в полях формы по умолчанию.

### Простая кнопка

Помимо кнопок отправки формы или сброса введенных значений, существуют и «просто кнопки». При нажатии на такую кнопку никаких действий не происходит, а все необходимые действия обычно задаются при помощи JavaScript.
Пример записи:

```html
<input type="button" value="Кнопка">
```

### Кнопка-изображение

В качестве кнопки отправки формы можно использовать изображение.
Для этого у тега input нужно указать тип image.
Аналогично обычным изображениям на сайте у кнопки-изображения есть еще два атрибута:

src	адрес изображения
alt	альтернативный текст, отображаемый в том случае, если изображение не загружено

Кнопка-изображение работает аналогично кнопке submit, но на сервер дополнительно передаются координаты точки, по которой был произведен щелчок.

### Альтернативный способ задания кнопок

Помимо тега `<input>` для добавления кнопок можно использовать тег `<button>`. Он расширяет возможности создания кнопок.

Внутри тега `<button>` можно размещать любые HTML-элементы, в том числе изображения. Например:

```html
<button>Календарь <img src="calend.png" alt=""></button>
```

Если в атрибуте type тега `<button>` указать значение submit или reset, то кнопка будет отправлять данные на сервер или сбрасывать введенные значения.
По умолчанию значение атрибута type — submit.
То есть внутри формы кнопка `<button>` по нажатию отправит форму на сервер.
Значениями атрибута type также могут быть button и reset.
Кнопка button со значением type="reset" аналогично input type="reset" сбрасывает значения полей формы к изначальным.
А вот значение type="button" избавит кнопку от всей изначальной функциональности. То есть кнопка просто будет выглядеть как кнопка, но ничего по умолчанию не делать. Это удобно, если вы хотите сами добавить кнопке дополнительное действие с помощью JavaScript.


### Обязательные поля

Ура, товарищи! Мы успешно разобрались с возможностями кнопок в формах и залогинились в профайл Кексика.
Теперь нам предстоит изучить новые возможности форм, большая часть которых была добавлена в HTML5. А в процессе мы будем помогать Кексику строить формы, используя полученные знания.
Итак, начнём...
Кексик, как и любой уважающий себя кот, любит рыбу. Но при этом каждый раз ходить в рыбную лавку за лососем ему лень. Поэтому он, как уважающий себя
инженер, решил облегчить свою жизнь автоматизацией процесса: он собрался сделать форму доставки любимых лакомств на дом, чтобы ей мог пользоваться он сам и его друзья-котаны. Кексик начал её верстать, и ему надо помочь в этом нелёгком деле.
Сначала давайте разберёмся с обязательными полями. Чтобы указать, что поле обязательно для заполнения, нужно добавить ему пустой атрибут required:

```html
<input type="text" required>
```

При попытке отправить форму с незаполненными обязательными полями браузер выведет всплывающее предупреждение

Эта проверка работает на клиентской части и упрощает валидацию форм.
Но всегда нужно проверять отправленные данные и на стороне сервера.


### Поле выбора даты

Поля для задания даты и времени уже поддерживаются в этих браузерах.
В форму заказа важно включить поле даты доставки. А для выбора даты из календаря существует новый тип поля ввода — date. При клике на данное поле в форме всплывает календарик.
Пример записи:

```html
<input type="date">
```

Если браузер не поддерживает поле для ввода даты, то вместо него отображается обычное текстовое поле.

### Поле выбора времени

Используем поле выбора времени в нашей форме:

```html
<input type="time">
```

Если браузер не поддерживает поле для ввода времени, то вместо него отображается обычное текстовое поле.

### Список возможных значений

Для текстовых полей можно заранее определить список возможных значений, которые отображаются, когда вы начинаете вводить текст в поле. Для этого существует специальный тег `<datalist>`.

Пример использования:

```html
<input type="text" list="browsers" name="browser">

<datalist id="browsers">
  <option value="Firefox"></option>
  <option value="Chrome"></option>
  <option value="Safari"></option>
</datalist>
```

Связывание текстового поля и списка осуществляется при помощи атрибута list у тега input — значение list должно быть таким же, как значение атрибута id у списка.
Если тег input имеет специфический тип, например email или другие, которые будут рассмотрены далее в курсе, то в списке отображаются только корректные для данного типа значения.

### Поле ввода числового значения

Для ввода числовых значений существует специальный тип поля ввода number. Рядом с полем браузер автоматически подставляет две стрелочки для увеличения и уменьшения числового значения.
Пример записи:

```html
<input type="number">
```

При помощи вспомогательных атрибутов min и max можно установить верхнюю и нижнюю границу допустимых значений. А атрибут step устанавливает величину шага изменения значения.
Также стоит отметить, что поле ввода числа, как и некоторые другие поля, которые будут рассмотрены дальше, по-особому ведёт себя в мобильных браузерах: например, при фокусе на такое поле появляется клавиатура, позволяющая вводить соответствующие символы.


### Поле поиска

Пример записи:
```html
<input type="search">
```

Это поле почти не отличается от обычного текстового поля. В некоторых браузерах внутри него появляется крестик для сброса введённого значения.

### Автофокус

При загрузке страницы можно сообщить браузеру в какое поле установить курсор по умолчанию. Для этого используется пустой атрибут autofocus.
Пример записи:

```html
<input type="text" autofocus>
```

Автофокус улучшает процесс работы с формами, ведь пользователь избавляется от лишних щелчков мышки, там где они не нужны, а может сразу начинать вводить текст в поле.
Обратите внимание, что такой атрибут должен быть только один на странице.

### Другие поля для ввода дат

В предыдущих заданиях мы уже использовали поля с типами date и time, но существуют и другие типы полей для ввода дат:
datetime-local	выбор даты с указанием времени (без учета временной зоны)
week	выбор порядкового номера недели в году и года
month	выбор месяца и года
Используем поле для выбора месяца в нашей форме. А для выбора числа используем уже знакомый тип number.

Если браузер не поддерживает поле для ввода месяца, то вместо него отображается обычное текстовое поле.

### Выбор из диапазона

В нашей форме обязательно должна быть возможность выбрать количество дней, на которое будет осуществляться бронирование. Для этой цели подходит тип поля range.
Такое поле выглядит как шкала с ползунком и позволяет выбрать число из некоторого интервала значений.
Пример записи:

```html
<input type="range" min="1" max="10">
```

Атрибуты min и max устанавливают нижнюю и верхнюю границу допустимых значений. А атрибут step устанавливает величину шага изменения значения.

### Область для вывода результата

Чтобы видеть количество дней в брони, используем тег `<output>`.
Тег `<output>` представляет собой область, куда выводятся какие-либо результаты вычислений, обычно полученные при помощи JavaScript.
Пример записи:

```html
<output name="sum">[значение по умолчанию]</output>
```

Значение по умолчанию при этом можно не задавать, тогда область вывода будет пустой.
В этом задании мы добавим в форму область вывода, в которой будет отображаться количество дней, выбранное с помощью поля-ползунка.

### Группировка полей формы

Когда формы становятся очень большими, возникает потребность зрительно отделить одни поля от других. Для группировки полей используется тег fieldset.

Пример:

```html
<fieldset>
  <input type="text">
  <input type="text">
  <input type="text">
</fieldset>
<fieldset>
  <textarea></textarea>
</fieldset>
```

По умолчанию браузеры отображают результат в виде рамки вокруг этой группы полей, но при помощи CSS можно изменить его внешний вид.
Также для каждой группы можно добавить её заголовок. Для этого внутрь тега fieldset надо поместить тег legend:

```html
<fieldset>
  <legend>Заголовок группы</legend>
  <input type="text">
</fieldset>
```

### Поле ввода телефона

Новый тип поля tel появился в HTML5 и отвечает за ввод телефонных номеров.
Также воспользуемся атрибутом pattern, чтобы исключить ошибки при заполнении формы.

### Подсказка при заполнении полей

У полей, в которые вводятся текстовые значения (textarea, разные типы input и так далее) есть возможность вывести подсказку.
Для этого используется специальный атрибут placeholder:

```html
<input type="text" placeholder="Текст подсказки">
```

Текст подсказки выводится внутри текстового поля, а при вводе значения — автоматически убирается.
Воспользуемся этим атрибутом, чтобы подсказывать в каком именно формате следует вводить номера котопаспорта и телефона.

### Поля ввода адресов сайтов и email

В HTML5 добавлены два типа полей email и url, предназначенные для ввода электронной почты и адреса сайта. Особенностью этих полей является то, что они автоматически проверяют формат введённых данных.
Пример записи:

```html
<input type="email">
<input type="url">
```

Внешне эти поля не отличаются от обычных текстовых полей, но обладают важной особенностью, которая очень полезна на мобильных устройствах.
Когда вы начинаете заполнять такое поле на мобильнике, там автоматически переключается раскладка клавиатуры. Например, для email отобразятся латинские символы, цифры, знак @ и некоторые другие

### Поле выбора цвета

В HTML5 добавили новый тип color, предназначенный для полей выбора цвета. При клике на такое поле появляется окно с возможностью выбрать цвет из палитры.
Пример записи:

```html
<input type="color">
```

### Группировка элементов списка

Так как список выбора может быть довольно большой, в теге select используем возможность объединять option в группы. Обычно это используется для большей наглядности и удобства поиска нужного варианта.
Для формирования группы используется тег optgroup. Атрибут label этого тега определяет заголовок группы.
Пример использования:

```html
<select name="variants">
  <optgroup label="Группа вариантов 1">
    <option value="1">Вариант 1</option>
    <option value="2">Вариант 2</option>
    <option value="3">Вариант 3</option>
  </optgroup>
  <optgroup label="Группа вариантов 2">
    <option value="4">Вариант 4</option>
    <option value="5">Вариант 5</option>
    <option value="6">Вариант 6</option>
  </optgroup>
</select>
```

Вложенность групп не ограничена, внутрь каждой группы можно вложить другие группы.
Аналогично можно группировать элементы и в списках со множественным выбором.

### Запрет редактирования полей

Есть два способа: использование атрибута readonly и использование атрибута disabled
Пример записи:

```html
<input type="text" readonly>
<input type="text" disabled>
```

В чем же отличие между ними?
Атрибут readonly не дает пользователю изменять поле (вводить новый текст, модифицировать существующий). Введенное значение можно выделить и скопировать. Данные из этого поля отправляются на сервер.
Атрибут disabled не дает пользователю изменять поле (вводить новый текст, модифицировать существующий). Нельзя поставить фокус в это поле, введенное значение нельзя выделять и копировать. Данные из этого поля НЕ отправляются на сервер.


### Управление автозаполнением полей

Браузер может запоминать значения, вводимые в текстовые поля. При вводе первых букв текста выводится список сохранённых ранее значений, из которого можно выбрать подходящее. Параметрами автозаполнения можно управлять используя атрибут autocomplete.
Он может принимать два значения on и off. Первое включает автозаполнение, второе — отключает. Отключение автозаполнения обычно используется из соображений безопасности, например, чтобы не сохранялись пароли, номера банковских карт и так далее.
Пример использования:

```html
<input type="text" autocomplete="off">
```

Значение по умолчанию зависит от настроек браузера

### Переключение между полями

При нажатии клавиши Tab браузер передает управление (фокус) от одного элемента к другому в том порядке, в котором они были объявлены на странице. Этим порядком можно управлять при помощи атрибута tabindex

Пример записи:

```html
<input type="text" tabindex="3">
```

В качестве значения может использоваться любое целое положительное число. Значения выстраиваются последовательно и переход между элементами происходит от меньшего значения к большему.
Если представлено отрицательное значение — элемент может быть выделен, однако не участвует в последовательной навигации
Если представлен 0 — элемент может быть выделен и достигнут с помощью последовательной навигации, однако порядок навигации определён платформой

### localStorage

Как справиться с этой довольно часто встречающейся проблемой, когда введённые в форму данные теряются?
Для этого можно использовать localStorage. Эта технология относится к JavaScript, а не к HTML или CSS, но промолчать о ней мы не можем.
Суть localStorage или «локального хранилища» заключается в том, что в него можно записывать данные, которые будут сохраняться в браузере. Эти данные не исчезнут даже если вы закроете браузер и откроете его снова или уйдете со страницы и потом вернётесь на неё.

Получается, что можно сохранять данные из формы в хранилище при работе с формой, а при загрузке страницы проверять хранилище на наличие данных, и если они есть, то подставлять их в форму. Таким образом можно предотвратить потерю данных при работе с формами.
Давайте проверим работу localStorage. Это просто. Мы уже всё подготовили, вам осталось только раскомментировать один тег.




## Селекторы, часть 1

### Нелёгкая жизнь без селекторов

Селекторы позволяют очень точно указывать к каким элементам применять CSS-свойства. Селекторы — это наш снайперский прицел, в этой главе мы будем учиться им пользоваться.
Так как глава посвящёна «стрельбе свойствами по элементам», то тема биатлона подходит как нельзя кстати. В каждом задании вам нужно будет с помощью селекторов закрывать мишени.
Но для начала представим, что механизма селекторов не существует. Как в этом случае задавать CSS-свойства элементам? С помощью атрибута style. Например:

```html
<p style="color: red;">...</p>
```

### Селекторы по тегам

Задавать атрибут style для каждого тега неудобно и долго. Особенно, если тот же результат можно получить с помощью единственного CSS-правила, в котором используется селектор для тега li.

С помощью селекторов по именам тегов можно задать стили для всех элементов списка, изображений, абзацев и так далее. Эти селекторы содержат имя тега без символов < и >. Например:

```html
li {
  /* стили для элементов списка */
}
```

Одно правило может относиться сразу к нескольким селекторам, в таком случае селекторы перечисляются через запятую:

```html
a, img {
  /* стили для ссылок и изображений */
}
```

### Селекторы по классам

Класс — это один из атрибутов тегов. Выглядит он вот так:

```html
<li class="first"></li>
```

Этот атрибут особенный, так как в CSS существует возможность выбирать элементы по классу. Делается это с помощью такого селектора: .имя_класса. Например:

```css
.first {
  /* стили для класса first */
}
```

Имена классов могут состоять из латинских символов, цифр и знаков - и _. Имя класса должно начинаться с латинской буквы.

### Отрабатываем селекторы по классам

Синтаксис CSS позволяет выбирать элементы не только по одному классу или тегу. Можно, например, выбрать элемент одновременно по тегу и по классу или же элемент с двумя классами сразу. Для этого селектор составляется просто одной строкой из всех желаемых «частей» без пробелов. Давайте рассмотрим примеры.
В селекторе по тегу и классу первым пишется название тега, а потом идёт класс:

```html
/* выбор всех тегов ul с классом target */
ul.target {...}

<ul class="target"></ul>
```

Если у элемента задано несколько классов, в HTML и в CSS-селекторе они могут идти в разном порядке — это не будет влиять на выборку элементов:

```html
/* выбор элементов с двумя классами: text и green */
.text.green {...}

<span class="text green"></span>
<p class="green text"></p>
```

Количество классов в селекторе может быть любым:

```css
/* выбор тегов span с четырьмя классами: underlined, red, big и text */
span.underlined.red.big.text {...}
```

```html
<span class="underlined red big text"></span>
```

### Контекстные селекторы

Селектор может состоять из нескольких частей, разделённых пробелом, например:

```css
p strong { ... }
ul .hit { ... }
.footer .menu a { ... }
```

Такие селекторы называют контекстными или вложенными. Их используют для того, чтобы применить стили к элементу, только если он вложен в нужный элемент.
Например, селектор .menu a сработает для ссылки a только в том случае, если она расположена внутри элемента с классом .menu.
Читать их проще всего справа налево:

```css
/* выбрать все теги strong внутри тегов p */
p strong { ... }

/* выбрать все элементы с классом .hit внутри тегов ul */
ul .hit { ... }

/* выбрать все ссылки внутри элементов с классом .menu,
   которые лежат внутри элементов с классом .footer */
.footer .menu a { ... }
```

Таким образом, можно задавать элементам различные стили в зависимости от их контекста. Если ссылка расположена внутри меню, сделать её крупнее, а если внутри основного текста, то задать ей нужный цвет

### Соседние селекторы

Контекстные селекторы используются для вложенных друг в друга элементов, а соседние — для расположенных рядом.
Например, теги `<li>` в списке являются соседними по отношению друг к другу и вложенными в тег `<ul>`.
Соседние селекторы записываются с помощью знака +, например, селектор1 + селектор2. Стили применятся к элементу, подходящему под селектор2, только если сразу перед ним расположен элемент, подходящий под селектор1.
Пример. Есть два элемента списка:

```html
<ul>
  <li class="hit"></li>
  <li class="miss"></li>
</ul>
```

Селектор .hit + .miss применит стили к элементу с классом miss, так как перед ним есть элемент с классом hit.
Селектор .hit + li, а также селектор li + .miss, или даже li + li тоже применит стили к элементу с классом miss, то есть ко второму элементу списка.
А вот селектор .miss + .hit не сработает, так как элемент с классом miss находится после элемента с классом hit в разметке.


### Контекстные и соседние селекторы

Селекторы в CSS можно очень гибко комбинировать. В частности, можно комбинировать контекстные и соседние селекторы

Псевдокласс добавляется к селектору c помощью символа :, вот так селектор:псевдокласс. Например:

```css
a:visited { ... }
li:last-child { ... }
.alert:hover { ... }
```

Знакомство с псевдоклассами мы начнём с first-child и last-child.
Псевдокласс first-child позволяет выбрать первый дочерний элемент родителя, а last-child — последний дочерний элемент. Например:
li:last-child { ... }
Этот селектор выберет последний элемент списка.

### Псевдокласс :nth-child

Псевдоклассы из предыдущего примера относятся к семейству псевдоклассов, помогающих выбирать элементы по их расположению.
Вспомним задание 4. В нём каждому тегу `<li>` был задан собственный класс. Используя классы, мы могли выбрать любой из пяти тегов. Если бы тегов было десять, то пришлось бы использовать десять разных классов.
С помощью псевдокласса nth-child можно выбирать теги по порядковому номеру, не используя классы. Синтаксис псевдокласса: селектор:nth-child(выражение). Выражением может быть число или формула. Например:

```css
1. li:nth-child(2) { ... }
2. li:nth-child(4) { ... }
3. li:nth-child(2n) { ... }
```

Первый селектор выберет второй элемент списка, второй селектор — четвёртый элемент списка, третий селектор — все чётные элементы.

### :nth-child и контекстные селекторы

Селекторы с псевдоклассами хорошо сочетаются с контекстными селекторами.
Например, следующий селектор выберет третий тег `<li>` внутри блока с классом shooter-2.

```css
.shooter-2 li:nth-child(3) { ... }
```

Селектор не обязательно должен заканчиваться псевдоклассом. Например, следующий селектор выберет элемент с классом .text в четвёртом элементе списка <li>.

```css
li:nth-child(4) .text { ... }
```

### Псевдокласс :hover

Некоторые псевдоклассы позволяют выбирать элементы, с которыми взаимодействует пользователь. Сначала познакомимся с псевдоклассом :hover.
Этот псевдокласс позволяет выбрать элемент, когда на него наведён курсор мыши и кнопка мыши не нажата. Примеры:

```css
1. a:hover { ... }
2. tr:hover { ... }
3 .menu-item:hover { ... }
```

Первый селектор выбирает ссылку, второй строку таблицы, третий элемент с классом menu-item, но только в том случае, если на них наведён курсор мыши.

Благодаря этому псевдоклассу можно добавлять в интерфейс динамику и интерактивность, так как элементы начинают реагировать на действия пользователя, изменяя свой внешний вид.

### Динамические эффекты с помощью :hover

Интересовались ли вы, как с помощью CSS создаются выпадающие меню?
Львиная доля динамических эффектов, создаваемых с помощью CSS, опираются на несколько псевдоклассов, главный из которых, конечно же, :hover. Весь секрет заключается в сочетании контекстных селекторов и псевдоклассов. Посмотрите на пример:

```css
li.top ul.submenu {
  display: none;
}

li.top:hover ul.submenu {
  display: block;
}
```

Первое правило прячет список-подменю. Второе правило гласит: «если на верхний пункт меню, в котором находится подменю, наведут курсор, то надо показать подменю». Вот так всё просто.
Общий принцип такой: родительский элемент реагирует на наведение мыши и изменяет свойства элементов-потомков. То есть всё работает на контекстных селекторах вида селектор1:hover селектор2.


### Псевдоклассы :link, :visited и :active

Отвлечёмся от биатлона и познакомимся с псевдоклассами для ссылок.

```css
●	:link выбирает ещё не посещённые ссылки.
●	:visited выбирает посещённые ссылки.
●	:active выбирает активные ссылки (кнопка мыши зажата на ссылке).
```

Пример задания CSS-правил для ссылок:

```css
a:link { ... }
a:visited { ... }
a:hover { ... }
a:active { ... }
```

Обратите внимание на порядок правил. Если их расположить по-другому, то некоторые могут не сработать.

### Псевдокласс :focus

Псевдокласс :focus позволяет выбрать элемент, который в данный момент в фокусе. Например, текстовое поле, в которое установлен курсор, находится в фокусе.
В фокусе могут быть не только текстовые поля. Если вы переключаетесь между элементами веб-страницы с помощью клавиши tab, то в фокус будут попадать ссылки.
Пример использования псевдокласса:

```css
input:focus {
  /* стили для поля в фокусе */
}
```

### Селекторы атрибутов

Ранее мы познакомились с атрибутом class и специальными селекторами по классу. Существуют селекторы, которые позволяют выбирать элементы по любым атрибутам.
Чаще всего такие селекторы используются при работе с формами, так как поля форм имеют атрибут type с разными значениями.
Селекторы атрибутов записываются с использованием квадратных скобок: элемент[атрибут]. Примеры селекторов:

```css
1. input[checked] { ... }
2. input[type="text"] { ... }
```

Первый селектор выберет поля формы, у которых есть атрибут checked, второй селектор выберет поля формы, у которых атрибут type имеет значение text.

### Селектор по id

Существует ещё один HTML-атрибут, для которого существует специальный селектор. Этот атрибут id (идентификатор), а селектор записывается с помощью символа #, например, #some-id.
На значение id распространяются те же ограничения, что и на имя класса. Также id должен быть уникальным на странице.
Пример:

```html
<p id="greeting">Приветствие!</p>
```

```css
CSS#greeting {
  ...
}
```

Использование селекторов по id при оформлении считается плохой практикой. Существуют редкие исключения из этого правила, например, при оживлении слайдера на чистом CSS.


## Глава 6. Наследование и каскадирование

### Иерархическое дерево

HTML-документ представляет собой иерархическое дерево. Это означает, что у каждого элемента (кроме корневого) есть только один родитель, то есть элемент, внутри которого он располагается. У корневого раздела родитель отсутствует. Рассмотрим простейшую страницу:

```html
<html>
   <head></head>
   <body>
      <p>Текст документа</p>
      <p class="text">Выделенная <span>строка</span></p>
   </body>
</html>
```

### Наследование

Наследование в CSS — механизм, с помощью которого значения свойств элемента-родителя передаются его элементам-потомкам.
Стили, присвоенные некоторому элементу, наследуются всеми потомками (вложенными элементами), если они не переопределены явно. Например, размер шрифта и его цвет достаточно применить к body, чтобы все элементы внутри имели те же свойства.
Наследование позволяет сократить размер таблицы стилей, но если стилей много, то отследить какой родительский элемент установил некоторое свойство, становится сложнее.

### Наследование «на пальцах»

Давайте на простых примерах подробнее разберёмся, в чём же преимущество наследования.
Рассмотрим пример:

```html
<p class="text">Cтрока c выделенным <span>словом</span></p>
```

Представим, что нам нужно установить красный цвет текста для всего текста. Зададим CSS-свойства следующим образом:

```css
.text {
  color: red;
}
```

Благодаря наследованию цвет текста в теге span автоматически станет красным:
Cтрока c выделенным словом
А так бы выглядел результат, если бы наследование не работало:
Cтрока c выделенным словом
Нам пришлось бы отдельно прописывать цвет текста для тега span. И тогда установка таких простых свойств как стиль шрифта стала бы большой проблемой: нужно было бы задавать свойства для всех возможных вложенных тегов.

### Ещё немного про наследование

Наверняка вы обращали внимание, что не все свойства наследуются тегами-потомками от их родителей.
Действительно, было бы странно, если бы свойство border автоматически устанавливалось для всех вложенных элементов.
Например, для этого куска кода:

```html
<p class="bordered">Cтрока c выделенным <span>словом</span></p>
```

Установим CSS-свойство:

```css
.bordered {
  border: 1px solid green;
}
```

Если бы наследовались все свойства, то результат бы выглядел так:
Cтрока c выделенным словом
На самом деле граница будет нарисована только у тега p.
О том, какие именно свойства наследуются, мы расскажем в следующих заданиях.

### Наследуемые свойства

К наследуемым свойствам относятся в первую очередь свойства, определяющие параметры отображения текста:

```css
font-size, font-family, font-style, font-weight, color, text-align, text-transform, text-indent, line-height, letter-spacing, word-spacing, white-space, direction и т. д.
```

Также к наследуемым свойствам относятся list-style, cursor, visibility, border-collapse и некоторые другие. Но они используются значительно реже.

Эти свойства можно и нужно задавать через предков, следуя семантике документа.
Например, параметры текста зачастую не меняются в пределах отдельных блоков страницы: меню, основного содержания, информационных панелей. Поэтому общие параметры текста (цвет, размер, гарнитура) обычно указывают в стилях самих блоков.

### Ненаследуемые свойства

В предыдущем задании мы перечислили основные наследуемые свойства. Все остальные относятся к ненаследуемым. Это параметры позиционирования, размеров, отступов, фона, рамок и т. д.
А именно:

```css
background, border, padding, margin, width, height, position и др.
```

Не наследуются они из соображений здравого смысла. Например: если для какого-либо блока установлен внутренний отступ, автоматически выставлять такой же отступ каждому вложенному элементу нет никакой надобности. Эти параметры чаще всего уникальны для каждого отдельного блока.

### Принудительное наследование

Для каждого свойства может быть задано значение inherit.
Оно означает, что данное свойство принимает такое же значение, как и у родительского элемента. Значение inherit может быть использовано для усиления наследуемых значений, а также в свойствах, которые обычно не наследуются.
Запись выглядит следующим образом:

```css
p {
  background: inherit;
}
```

В данном случае у тегов p свойство background будет таким же, как и у их родительских тегов.

### Каскадирование

CSS расшифровывается как «Cascading Style Sheets» или «каскадные таблицы стилей».
Каскадность обозначает, что к одному и тому же элементу может применяться несколько CSS-правил (наборов CSS-свойств). Среди этих свойств могут быть и конфликтующие между собой. Поэтому существуют инструкции, которые определяют, каким будет финальный набор свойств элемента.
Например, для элемента:

```html
<p class="text" style="color: red;"></p>
```

CSS-правила существуют как минимум в трёх разных местах:

1.	в подключаемом файле style.css для селекторов p или .text;
2.	в атрибуте style;
3.	в стандартных стилях отображения, встроенных в браузер.

Каскадирование как раз и определяет, какие именно свойства из этих источников применятся к данному абзацу.
Имеется три основные концепции, управляющие порядком, в котором применяются CSS-свойства:
1.	важность;
2.	специфичность;
3.	порядок исходного кода.
Самыми важными для нас являются последние две и подробнее о них мы поговорим отдельно.

### Битва за курочку

Перед тем как разбирать сложные правила работы каскадирования, расчёта специфичности и определения приоритетов, потренируемся на котиках.
Разберём пример. Вот HTML-код, в котором есть абзац с двумя классами:

```html
<p class="red blue">Синий или красный?</p>
```

А вот CSS-код c двумя правилами для этих классов:

```css
.blue {
  color: blue;
}

.red {
  color: red;
}
```

Вопрос: какого цвета будет текст абзаца? Какое из CSS-правил приоритетнее?
Ответ: красного цвета, второе правило приоритетнее.
Это происходит потому, что селекторы у правил одинакового типа, и соответственно обладают одинаковой специфичностью. В таком случае более высоким приоритетом обладает то правило, которое расположено в CSS-коде ниже. В нашем случае это правило для класса red.
В этой серии заданий вам нельзя менять значения CSS-свойств, но можно изменять селекторы или менять порядок CSS-правил в коде.

### Битва за курочку. Раунд второй

Чуть более сложный пример. Тот же HTML:

```html
<p class="red blue">Синий или красный?</p>
```

Немного другой CSS:

```css
p.blue {
  color: blue;
}

.red {
  color: red;
}
```

В этом случае текст абзаца будет синим. Происходит это потому, что селектор p.blue более специфичный, чем селектор .red.
Простое объяснение специфичности звучит так:
Чем меньшее количество элементов потенциально может выбрать селектор, тем он специфичнее.
В нашем примере селектор .red выберет все теги с нужным классом, а селектор p.blue выберет только абзацы с нужным классом.
Заметьте, что в этом задании одно из CSS-правил вынесено в заблокированный HTML-код, а вам нужно победить его, усилив другое CSS-правило.


### Битва за курочку. Раунд третий

А теперь посмотрим, как ведут себя контекстные селекторы.

```html
<div class="experiment">
  <p class="red blue">Синий или красный?</p>
</div>
```

И в CSS используем контекстный селектор для второго правила:

```css
p.blue {
  color: blue;
}

.experiment .red {
  color: red;
}
```

### Битва за курочку. Борьба накаляется

Как вы уже знаете, существуют селекторы не только по классам, но и по id. Они начинаются с решётки #.

HTML:

```html
<div id="experiment-1" class="experiment">
  <p class="red blue">Синий или красный?</p>
</div>
```

CSS:

```css
#experiment-1 .blue {
  color: blue;
}
.experiment .red {
  color: red;
}
```

Особенность атрибута id заключается в том, что его значение должно быть уникальным в пределах страницы. То есть, может существовать только один тег с определённым значением id.
Получается, что селектор по id может выбрать только один элемент. И поэтому он на порядок специфичнее селекторов по тегам, классам, а также комбинаций этих селекторов.


### Битва за курочку. Запрещённый приём

Битва подходит к концу, и чтобы удержать победу, Рудольф решается на запрещённый приём: он прописывает стили с помощью атрибута style прямо в теге курочки.
CSS-правила, которые прописаны в style обладают наивысшим приоритетом. Такой способ задания стилей не приветствуется в профессиональной вёрстке сайтов и годится только для создания быстрых прототипов. Поэтому мы и назвали этот приём запрещённым.
Однако существует способ переопределить из подключаемых CSS-файлов даже стили, заданные в атрибуте style. Для этого нужно использовать ключевое слово !important. Оно задаёт CSS-свойству усиленный приоритет. Вот пример:
HTML:

```html
<p style="color: red;" class="blue">Синий или красный?</p>
```

CSS:

```css
.blue {
  color: blue !important;
}
```

Цвет текста в этом примере будет синим.
При вёрстке не рекомендуется часто использовать !important. По возможности старайтесь обходиться без него.


### Ещё одна задачка на специфичность

Как вы уже догадались, самым главным механизмом для определения приоритетов стилей является специфичность. Поэтому давайте ещё немного потренируемся работать с ней.
Рассмотрим пример: на полу в коробке сидит кот

```html
<div id="floor">
  <span class="cat-in-box">Кексик</span>
</div>
```

Допустим в стилях существуют следующие определения:

```css
span {
  background-color: #27ae60; /* Зелёный */
}

div span {
  background-color: #2980b9; /* Синий */
}

#floor .cat-in-box {
  background-color: #34495e; /* Мокрый асфальт */
}

.cat-in-box {
  background-color: #8e44ad; /* Фиолетовый */
}

#floor span {
  background-color: #c0392b; /* Красный */
}

div .cat-in-box {
  background-color: #e67e22; /* Оранжевый */
}
```

А теперь вопрос на засыпку: какого цвета будет коробка? Сначала сделайте предположение, а затем проверьте.
Почему именно такой и как это определяется мы расскажем в следующем задании.


### Расчёт значения специфичности

Вы вдоволь наигрались со специфичностью, а теперь пришло время изучить полные правила её вычисления.
Специфичность селектора разбивается на 4 группы — a, b, c, d:
●	если стиль встроенный, то есть определён как style="...", то а=1, иначе a=0;
●	значение b равно количеству идентификаторов (тех, которые начинаются с #) в селекторе;
●	значение c равно количеству классов, псевдоклассов и селекторов атрибутов;
●	значение d равно количеству селекторов типов элементов и псевдо-элементов.

После этого полученное значение приводится к числу (обычно в десятичной системе счисления). Селектор, обладающий большим значением специфичности, обладает и большим приоритетом.
Посчитаем специфичность в нашем примере:

Селектор	a, b, c, d	Число
span	0, 0, 0, 1	1
div.cat-in-box	0, 0, 1, 1	11
#floor.cat-in-box	0, 1, 1, 0	110
div span	0, 0, 0, 2	2
.cat-in-box	0, 0, 1, 0	10
#floor span	0, 1, 0, 1	101

Отсюда сразу видно, что в нашем примере самым приоритетным является селектор #floor.cat-in-box.

### Перекрёстное наследование

При создании стилей для сходных по внешнему виду или функциональности элементов, которые могут использоваться на странице неоднократно, очень удобно пользоваться перекрёстным наследованием.
Приём этот заключается в следующем:
1.	создаётся базовый стиль для таких элементов;
2.	определяются вспомогательные стили, которые применяются к элементам по мере надобности;
3.	элемент наследует базовый стиль и один или несколько вспомогательных.
Пример:
На странице используются кнопки разного назначения: для отправки форм, для сброса информации в полях формы, как элементы навигации и т. д.
Можно вынести общее оформление (размеры, отступы и так далее) для всех кнопок в отдельное CSS-правило для класса, например, .button.
А затем создать дополнительные CSS-правила, в которых будут определены только различающиеся свойства этих кнопок, например, цвет фона. Для этих правил можно использовать такие названия классов: .button-send, .button-clear, .button-navigation.
Каждая кнопка в HTML-коде будет иметь два класса: общий и дополнительный.

```html
<a class="button button-send">Отправить</a>
```



## Глава 7. Фоны, часть 1

### Cвойство background-color

Цвет фона можно задать с помощью CSS-свойства background-color.
Напомним, что цвета в CSS можно задавать в разных форматах: в шестнадцатеричном (или HEX), в RGB или RGBA, а также с помощью цветовых констант, таких как red или green.
Более подробно о цветах можно прочитать на странице HTML Colors или в переводной статье о теории цвета на Хабре.
Вот пример использования свойства:

```css
selector {
  background-color: #ff0000;
}
```

### Свойство background-image

Фоновое изображение можно задать с помощью CSS-свойства background-image. Делается это так:

```css
selector {
  background-image: url("адрес-картинки");
}
```

Адрес картинки обязательно заключается внутрь url("..."). Адреса фоновых картинок такие же, как и адреса обычных картинок, которые вы задавали в курсе про ссылки и изображения.
Элементу можно одновременно задавать и цвет фона, и фоновую картинку. В этом случае картинка будет отображаться поверх фонового цвета.


### Свойство background-repeat

По умолчанию фоновое изображение повторяется. Это хорошо заметно, когда оно меньше блока. Управлять этим поведением можно с помощью CSS-свойства background-repeat. У свойства 4 значения:
●	repeat — повторять во всех направлениях. Это значение по умолчанию.
●	repeat-x — повторять только по горизонтали.
●	repeat-y — повторять только по вертикали.
●	no-repeat — не повторять.

### Свойство background-position

Cвойство background-position управляет расположением фонового изображения. Значение свойства состоит из двух частей, разделенных пробелом: x y.
x задаёт расположение по горизонтали, а y по вертикали.
В качестве значения x можно использовать ключевые слова left, center, right, значения в процентах и в пикселях.
В качестве значения y можно использовать ключевые слова top, center, bottom, значения в процентах и в пикселях.
Примеры использования свойства:
background-position: 50% 50%;

```css
background-position: right bottom;
background-position: 50px 100px;
background-position: 0 100%;
background-position: left bottom;
```

Так сработают примеры:
1.	картинка будет по центру;
2.	правый нижний угол;
3.	отступ 50px от левого края и 100px от верхнего;
4.	левый нижний угол;
5.	левый нижний угол.

### Ещё немного background-position

Когда фоновое изображение больше блока, то оно обрезается. Управлять тем, какую часть изображения будет видно, также можно с помощью свойства background-position.
Иногда для этого удобно использовать относительные значения (проценты), а иногда абсолютные (пиксели).
Кстати, можно использовать не только положительные, но и отрицательные значения. А также комбинировать пиксели и проценты.

### Свойство background-attachment

Обычно фоновое изображение прокручивается вместе с содержимым блока. Это хорошо видно в мини-браузере. Прокрутите окно вниз и увидите, что фон поднимется наверх.
С помощью свойства background-attachment можно зафиксировать фон на месте и он не будет перемещаться при прокручивании.
Значение свойства:

●	scroll — фон прокручивается вместе с содержимым. Это значение по умолчанию.
●	fixed — фон не прокручивается, зафиксирован на одном месте.
Это тот случай, когда легче показать, чем объяснять: выполняйте задание и смотрите, как изменяется поведение фона при прокрутке

### Свойство background

Фон элемента можно задавать с помощью отдельных свойств: background-color, background-image и так далее. Получается довольно громоздкая запись.
Также задать фон можно с помощью сокращенного свойства background, в котором через пробел перечисляются его компоненты:

```css
background: [bc] [bi] [br] [bp] [ba];
/* Обозначения:
[bc] — background-color
[bi] — background-image
[br] — background-repeat
[bp] — background-position
[ba] — background-attachment
*/
```

Если какой-то компонент не указан, то берется значение по умолчанию. Ниже примеры.

```css
background: #e74c3c;
background: url("img.png") no-repeat;
background: url("img.png") 10px 20px;
```

В первом примере просто задан цвет фона.
Во втором примере задано не повторяющееся фоновое изображение, а также по умолчанию прозрачный цвет фона, расположение в левом верхнем углу.
В третьем примере задано фоновое изображение и его расположение, а также по умолчанию прозрачный цвет фона и режим повторения во все стороны.


### Формат JPEG

В последующих нескольких заданиях мы рассмотрим наиболее распространенные форматы изображений для веб. И разберемся, где и как их лучше использовать при вёрстке.
Первый формат — JPEG. Этот формат хорошо подходит для фотографий и картин и плохо подходит для схем, чертежей, текста и графики.
При сохранении изображения в формат JPEG можно задавать уровень качества. Это позволяет добиваться снижения веса файла при достаточно хорошем качестве изображения.
Однако, если установить уровень качества слишком низким, то появятся артефакты.
JPEG не поддерживает прозрачность, поэтому изображение в формате JPEG — это всегда прямоугольник. Можно имитировать прозрачность, если в графическом редакторе задать изображению такой же цвет фона, как и у контейнера фотографии.
Используйте JPEG для размещения фото с наилучшим соотношением "размер файла"/"качество".

### Формат PNG-8

На самом деле, формат PNG один. А PNG-8 и PNG-24 это его подтипы, а также режимы сохранения в Photoshop. Мы не будем глубоко вдаваться в детали, а разберем типовые особенности.
PNG-8 по характеристикам схож с форматом GIF. Он хорошо подходит для схем, чертежей, графиков и текста, а также изображений, где мало цветов. Максимальное количество цветов — 256.
PNG-8, как и GIF, поддерживает прозрачность. Это означает, что пиксель либо полностью прозрачный, либо полностью непрозрачный.

Если нужно сделать изображение с прозрачностью, то лучше задавать обводку такую же, как цвет фона. В фотошопе при сохранении обводка называется «Matte». Без обводки картинка будет выглядеть «обкусанной». Если фон неоднородный (градиент, 3 блок в мини-браузере), то PNG-8 с обводкой будет смотреться плохо.
Чем PNG лучше GIF? PNG более современный и свободный формат, а GIF более старый и проприетарный (за его использование могут потребовать деньги). Уровень сжатия, качество и другие характеристики примерно одинаковые, поэтому лучше всегда использовать PNG.

### Формат PNG-24

PNG-24 — отличнейший формат. Он хорошо подходит и для схем-чертежей-графиков-текста, и для сложных многоцветных изображений, так как поддерживает практически неограниченное количество цветов.
На фотографиях обычно он уступает JPEG по размеру файла, но превосходит по качеству изображения. Но иногда разница по размеру файла настолько некритична, что можно использовать PNG.
Самый главный плюс PNG-24 — это полноценная поддержка полупрозрачности, которой нет ни в одном другом формате. Поэтому в веб-разработке при вёрстке сложных фонов, графических элементов со сложными тенями и так далее альтернативы PNG-24 просто нет.
Давным-давно в IE была проблема с поддержкой полупрозрачных PNG, но в более поздних версиях IE (8+), таких проблем нет.
Сравните котика-PNG-8 с обводкой из предыдущего задания и котика-PNG-24 из этого задания. Особенно то, как выглядят их края на желтом блоке и блоке с градиентом.
Некоторые верстальщики перестают использовать PNG-8 и используют только PNG-24.

### Формат GIF

Наверное, единственная причина использовать GIF заключается в том, что он поддерживает анимированные изображения.
Во всех остальных случаях используйте PNG или JPEG (если речь идёт о фотографиях и PNG даёт слишком тяжёлый файл).

### Несколько фонов

Несколько фонов одному элементу можно задать с помощью множественных фонов. Эта и другие возможности рассмотрены в продолжении курса — «Рамки и фоны, часть 2».
А сейчас рассмотрим старую надёжную технику создания нескольких фонов.
Суть техники заключается в том, что мы вкладываем элементы друг в друга и делаем их одинакового размера, а затем каждому элементу задаём свой фон. То есть каждый элемент служит одним слоем фона.
Фоны вложенных элементов перекрывают друг друга: чем глубже элемент, тем выше его фон.
Кстати, для удобства ширину лучше задавать внешнему элементу (так как все вложенные будут той же ширины), а высоту самому глубокому, так как он растянет по высоте всех своих родителей.

### Эффекты с повторяющимся фоном

Повторяющийся фон, тот у которого repeat, repeat-x или repeat-y, часто используется для создания интересных декоративных эффектов.
Например:
●	стежки;
●	зазубренные края;
●	градиенты и тени.

Да, сейчас уже градиенты и тени можно делать с помощью CSS. Но иногда, когда тень или градиент достаточно сложные, проще использовать полупрозрачный PNG.
Самое главное при создании таких эффектов — выбрать картинку с нужным периодом. Она может быть очень маленькой и даст существенную экономию веса страницы.
Попрактикуемся. Только, пожалуйста, изменяйте режим повторения после того, как пропишете фоновые изображения. Так будет нагляднее.

### Спрайты

Спрайт — это одно большое изображение, в котором содержится много маленьких, как бы карта изображений. Вот живой пример (эта же картинка выведена на тёмном фоне внизу мини-браузера), который мы будем использовать в задании.
Спрайты используются, чтобы снизить количество запросов на сервер. Каждая маленькая картинка — это отдельный запрос, а чем меньше запросов, тем лучше. Поэтому маленькие картинки «склеивают» в одну большую.
Части спрайта отображают в элементах с небольшими размерами. Такому элементу задают картинку-спрайт в качестве фона и смещают её таким образом, чтобы была видна нужная её часть.
В спрайты обычно объединяют иконки и различные мелкие декоративные изображения. Кстати, есть сервисы для быстрого создания спрайтов и генерации CSS-кода для них, например, SpritePad.




## Глава 8. Селекторы, часть 2

### Объединение селекторов

Иногда может потребоваться выбрать элементы, которые одновременно удовлетворяют сразу нескольким условиям.
В CSS есть запись, которая фактически выполняет операцию логического умножения, «И». Селекторы, применяемые к одному элементу, в этом случае пишутся без пробелов:

```css
.class1.class2 { }
```

Стили будут применяться ко всем элементам, которые одновременно имеют класс class1 и class2. Ведь это же не новость для вас, что HTML-элементы могут одновременно иметь несколько классов. Например:

```html
<div class="class1 class2">Блок с двумя классами</div>
```

По такому же принципу можно объединять любое количество абсолютно разных селекторов. И чем больше селекторов вы объединяете, тем больше условий должно совпасть для применения стилей.
В программировании похожую операцию часто обозначают как &&. Например:

```js
if (firstSelector && secondSelector) { ... }
```

### Псевдокласс :not

Псевдокласс :not(селектор) является отрицающим селектором. С его помощью можно выбрать элементы, которые НЕ содержат указанный селектор:

```css
li:not(:last-child) { }
```

Этот селектор выберет все теги `<li>`, НЕ являющиеся последними в их родителе.
Псевдокласс :not похож на оператор ! в программировании:

```js
if (!selector) { ... }
```

В качестве селектора могут указываться псевдоклассы, теги, идентификаторы, классы и селекторы атрибутов. Нельзя использовать двойной псевдокласс :not, то есть конструкция :not(:not(...)) не сработает.

Также в комбинации с :not не применяются:
●	объединение селекторов: например, li:not(.heart.jack) — некорректный селектор;
●	псевдоэлементы: li:not(::after) — неправильная запись (подробнее о псевдоэлементах рассказано далее в курсе);
●	селекторы-потомки, групповые селекторы или комбинации: например, нельзя писать li:not(a span) или li:not(a + span).

### Комбинируем :not

Отрицающий селектор :not, как и любые другие селекторы, можно комбинировать с другими. Например:

```css
li:not(:first-child):not(:last-child) { }
```

Выберет все теги `<li>`, которые НЕ являются первыми и последними в их родителе.

### Псевдокласс :nth-last-child

В первом курсе про селекторы мы уже рассматривали псевдокласс :nth-child, сейчас посмотрим на :nth-last-child.
Псевдокласс :nth-last-child используется для добавления стиля к элементам на основе нумерации в дереве элементов. В отличие от псевдокласса :nth-child, отсчет ведется не от первого элемента, а от последнего. Вот и все различия.

### Псевдокласс :first-of-type

Псевдокласс :first-of-type очень похож на :first-child. Он выбирает первый дочерний элемент родителя, только с учетом типа элементов.
Например, в этом задании перед списками с картами есть блок с текстом. У списков и у блока с текстом общий родитель — body.

```html
<body>
  <div class="paper"> … </div>
  <ul class="cards"> … </ul>
  <ul class="cards"> … </ul>
</body>
```

Сравним две записи:

```css
ul:first-child {
  background-color: #ffffee;
}
ul:first-of-type {
  background-color: #ffffee;
}
```

Верхний селектор выбирает первый дочерний элемент в родителе, причем этот элемент должен быть ul. В нашем случае не выберется ничего, потому что первым дочерним элементом body является div.
Нижний селектор выбирает первый ul среди всех дочерних ul в своем родителе. В нашем случае будет выбрана первая строка с картами.

### Псевдокласс :last-of-type

В предыдущем задании мы рассмотрели псевдокласс :first-of-type.
Псевдокласс :last-of-type работает аналогично, только выбирает последний дочерний элемент родителя с учетом типа.
Пример записи:

```css
ul:last-of-type {
  ...
}
```

### Псевдокласс :nth-of-type

Псевдокласс :nth-of-type работает почти так же, как и :nth-child. Разница заключается в том, что он учитывает тип элемента.
Вы можете обратиться к разбору примера в пятом задании, чтобы разобраться в отличиях этих селекторов.
Еще пример. Если в текущем задании мы используем такие селекторы:

```css
ul:nth-child(2) { }
ul:nth-of-type(2) { }
```

То верхний cелектор выберет второй по счёту дочерний элемент и этот элемент должен быть ul. В нашем случае выберется первая строка карт.
А нижний селектор выберет второй по счету ul среди дочерних ul. В нашем случае выберется вторая строка карт.

Псевдокласс :nth-of-type также работает с ключевыми словами odd и even. Значение odd позволяет выбрать все нечётные элементы, а значение even - все чётные элементы указанного типа. Подробнее о работе с этими ключевыми словами рассказано в пошаговой демонстрации Использование псевдокласса :nth-child

### Псевдокласс :nth-last-of-type

Наверняка, вы и сами уже прекрасно догадались, как будет работать :nth-last-of-type.
Элементы выбираются по их расположению, отсчет ведется от конца, учитывается тип элемента.
Пример записи:

```css
ul:nth-last-of-type(2) { }
```

Когда набор элементов не очень большой, все эти псевдоклассы :nth-child, :nth-of-type, :nth-last-child, :nth-last-of-type можно легко заменить один другим.
На более сложных структурах зачастую бывает удобнее использовать только определённые из них. Например, когда нужно выделять второй элемент с конца, но количество элементов в списке изменяется.

### Cелектор последующих элементов

Ранее мы уже рассматривали соседние селекторы, которые записываются как селектор1 + селектор2.
Есть похожий селектор селектор1 ~ селектор2. Стили применятся к элементу, подходящему под селектор2, только если перед ним расположен элемент, подходящий под селектор1. Оба элемента должны принадлежать одному родителю.
Отличие от соседнего селектора состоит в том, что между элементами селектор1 и селектор2 могут находиться другие элементы. Поэтому будем называть селектор1 ~ селектор2 селектором следующих элементов.
Сравним:

```html
<ul class="cards">
  <li class="king diamond">
  <li class="queen heart">
  <li class="jack spade">
  <li class="ace heart">
  <li class="king club">
</ul>
```

```css
.queen.heart + li {
  background-color: #ffff99;
}

.king.diamond ~ li {
  background-color: #99ddff;
}
```

В первом случае выделится одна карта, расположенная сразу за червовой дамой, то есть пиковый валет.
Во втором случае выделятся все карты, которые стоят за бубновым королем, то есть червовая дама, пиковый валет, червовый туз и трефовый король.


### Псевдокласс :empty

Псевдокласс :empty, выбирает только те теги, у которых нет дочерних элементов (в том числе текстовых узлов). Учтите, что даже переход на новую строку считается текстовым узлом, помните об этом в процессе проектирования структуры страницы.
Пример:

```css
ul:empty {
  ...
}
```
В данном случае выберутся все пустые элементы ul.

### Псевдокласс :only-child

Псевдокласс :only-child пригодится, когда нужно прописать индивидуальные стили для элемента, который является единственным дочерним элементом внутри родительского контейнера.
Пример:

```css
li:only-child {
  ...
}
```

Сработает, когда этот `<li>` в списке единственный.
Cелектор :only-child эквивалентен селектору elem:last-child:first-child.

### Псевдокласс :only-of-type

Псевдокласс :only-of-type работает почти так же, как и :only-child. Отличие состоит в том, что он учитывает тип элемента.
Пример:

```css
p:only-of-type {
  ...
}
```

В данном случае стили будут применены к элементу p, если это единственный p внутри своего родителя.

### Псевдоэлемент ::before

Псевдоэлемент before позволяет с помощью CSS добавить псевдотег внутрь другого элемента и оформить его. Cодержимое псевдотега задаётся с помощью свойства content.
Например, у нас есть такой HTML:

```html
<div class="queen heart">
  <em>Дама</em>
</div>
```

Добавим CSS-правило с необычным селектором с двойным двоеточием:

```css
.heart::before { content: "Черви"; }
```

И HTML изменится вот так:

```html
<div class="queen heart">
  <before>Черви</before>
  <em>Дама</em>
</div>
```

Но! Исходный HTML-код не изменится, тег `<before>` не попадёт в код страницы, а будет «виртуально» существовать где-то в браузере. Поэтому мы и используем приставку псевдо.
Ведёт себя псевдотег так же, как обычный `<span>` с текстом. Ему можно задавать дополнительные стили, например:

```css
.heart::before {
  content: "Черви";
  color: red;
}
```

Чтобы псевдоэлемент появился, ему необходимо задать свойство content. Достаточно даже пустой строки в значении свойства — content: "";.

### Псевдоэлемент ::after

Псевдоэлемент after аналогичен before. Отличие заключается в том, что он добавляет псевдотег не в начало, а в конец элемента. Например:

```css
.heart::after { content: "Черви"; }
```

Даст такой результат:

```html
<div class="queen heart">
  <em>Дама</em>
  <after>Черви</after>
</div>
```

Псевдоэлементы before и after можно использовать одновременно. Это означает, что с помощью CSS вы можете добавить к любому элементу на странице два псевдоэлемента.

Обратите внимание, что псевдоэлементы пишутся с двойным двоеточием. Этим они отличаются от псевдоклассов, которые используют одинарное двоеточие.

### Позиционирование псевдоэлементов

Вы можете задавать псевдоэлементам любые CSS-свойства. Можно менять тип элемента, задавать ему позиционирование, отступы, фон и так далее.

Этими возможностями особенно часто пользуются при создании различных декоративных эффектов. Это очень удобно.
Во-первых, не нужно добавлять лишний тег под каждую очередную мелкую иконку.
Во-вторых, можно управлять этими иконками/декоративными элементами только с помощью CSS, что открывает огромный простор для создания интересных динамических эффектов.


### Фон для псевдоэлементов

Наша карта почти готова. Осталось сделать последний штрих — задать фоны самой карте и псевдоэлементам.
Кстати, мы перевернули нижнюю иконку с помощью CSS-свойства transform, которое будет рассмотрено в курсе про двумерные трансформации.

Также для управления размером фонового изображения мы использовали свойство background-size, которое рассмотрим в курсе про рамки и фоны.

### Псевдоэлементы ::first-line и ::first-letter

Отвлечемся от карт и обратимся к тексту.
Псевдоэлемент first-line задает стиль первой строки форматированного текста. Длина этой строки зависит от многих факторов, таких как используемый шрифт, размер окна браузера, ширина блока, языка и так далее. В правилах стиля допустимо использовать только свойства, относящиеся к шрифту, изменению цвета текста и фона.
Пример использования:

```css
p::first-line { }
```

Аналогично псевдоэлемент first-letter определяет стиль первого символа в тексте элемента, к которому добавляется. К этому псевдоэлементу могут
применяться только стилевые свойства, связанные со свойствами шрифта, полями, отступами, границами, цветом и фоном.
Пример использования:

```css
p::first-letter { }
```



































































