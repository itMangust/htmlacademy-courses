
# CSS
CSS расшифровывается как `«Cascading Style Sheets»`, то есть «каскадные таблицы стилей».

Язык CSS отвечает за внешний вид страницы.

С помощью CSS можно задавать параметры для любого тега: ширину и высоту, отступы, цвет и размер шрифта, фон и так далее. Все эти параметры задаются с помощью свойств в следующем формате:

```html
свойство: значение;
```

Например:

```html
color: red;
padding: 10px;
```
Стили к тегам добавляются чаще всего при помощи атрибута class.


Например, если мы хотим, чтобы определённые стили, описанные, допустим, в классе feature-kitten, применились к тегу `<p>`, то в разметке напишем так:

```html
<p class="feature-kitten">...</p>
```


## CSS-правила
Можно сказать, что CSS-правило — это группа свойств и их значений, которая целиком применяется к тем тегам, на которые указывает селектор.

И выглядит это так:

```html
селектор {
  свойство1: значение;
  свойство2: значение;
}
```

Задавать стили можно не только с помощью атрибута class, но и по тегам. Селектор указывает, к каким тегам применятся свойства из CSS-правила. Селекторы по тегам работают проще всего: они выбирают все теги с подходящим именем.

```html
p { color: red; }
```

В примере селектором является p, и он выбирает все теги с именем p (то есть теги `<p>`), а теги с другим именем, например h1, не выбирает.

Когда же стилизация задаётся по классам, то стили применяются только к тегам с такими классами.

```html
.название_класса {
  свойство: значение;
}
```

## Миксование классов
У HTML-элемента может быть сколько угодно классов, в этом случае они перечисляются в атрибуте class через пробел, например:

```html
<li class="product">Товар</li>
<li class="product hit">Товар, а ещё хит продаж</li>
<li class="product hit sale">Товар, хит продаж и со ски-и-идкой!</li>
```

Обычно миксование используют так: в один класс выносят общее оформление, а в дополнительных классах описывают его модификации.

## Переопределение стилей

Чтобы задать всем товарам один цвет фона, а хитам другой, можно сделать так:


```css
.product {
  …                         /* общие размеры и отступы */
  background-color: gray;   /* серый фон по умолчанию */
}

.hit {
  background-color: yellow; /* жёлтый фон у хитов */
}
```

Оба CSS-правила подействуют на второй товар, ведь у него есть два подходящих класса. Но чтобы цвет фона стал жёлтым, правило .hit должно находиться в коде ниже правила .product. В этом случае свойство background-color из второго правила переопределит значение свойства background-color из первого правила.


## Комментарии
В CSS тоже существуют комментарии, их отличие от HTML-комментариев в том, что код или подсказки пишутся между символами `/*` и `*/`.




# Основы CSS
### CSS-правила
`CSS` — это язык для оформления структурированных документов, например, HTML- документов. Синтаксис — это плоский список CSS-правил. CSS-правило состоит из селектора и перечня свойств и их значений:

```css
селектор {
  свойство: значение;
  свойство: значение;
}
```

Для комментариев в CSS используются символы `/*` и `*/`.

### Селекторы
Селектор находится в начале CSS-правила, до фигурных скобок, и определяет, к каким HTML-элементам применятся свойства и значения из правила.

```css
.feature-kitten {
  padding-top: 60px;
}
```

Простейшие (и самые популярные) селекторы — это селекторы по тегам и по классам. Селекторы по тегам содержат имя тега без символов < и > и применяются ко всем подходящим тегам. Селекторы по классам начинаются с точки, за которой идёт имя класса, и применяются ко всем тегам с подходящим атрибутом class.

```css
h1 { color: red; }
.info { color: blue; }
```

На странице может быть несколько списков, и стили применятся ко всем спискам, даже к тем, которые вы менять не хотели. Чтобы избежать таких ситуаций, лучше не использовать селекторы по тегам или использовать их как можно реже.

Если у CSS-правил отличаются только селекторы, а свойства и значения одинаковые, то их можно сгруппировать через запятую.

Также можно комбинировать любые типы селекторов через пробел. Такие селекторы называются вложенными или контекстными и читаются справа налево. Например:

```css
nav a {…}
.menu ul {…}
.post .title {…}
```

### Свойства и значения
Список свойств и значений находится внутри фигурных скобок CSS-правила. Свойство определяет, какую характеристику внешнего вида мы хотим изменить, а значение — как именно.

```css
.feature-kitten {
  padding-top: 60px;
}
```

Каждый раз, когда мы добавляем новое свойство или изменяем его значение, мы меняем что-то на странице.

### Наследование
Наследование в CSS — это механизм, с помощью которого значения свойств элемента-родителя передаются его элементам-потомкам. Стили, присвоенные одному элементу, наследуются всеми потомками (вложенными элементами), но только в том случае, если они где-то явно не переопределены.

### Наследуемые свойства

На самом деле не все свойства в CSS наследуются. К наследуемым относятся в основном свойства, определяющие параметры отображения текста:

```html
font-size, font-family, font-style, font-weight, color, text-align, text-transform, text-indent, line-height, letter-spacing, word-spacing, white-space, direction и другие
```

Также к наследуемым свойствам относятся `list-style`, `cursor`, `visibility`, `border-collapse` и некоторые другие. Но они используются значительно реже.

Наследуемые свойства можно и нужно задавать через предков, следуя структуре документа.

Например, параметры текста зачастую не меняются в пределах крупных блоков страницы: меню, основного содержания, информационных панелей. Поэтому общие параметры текста (цвет, размер, гарнитура) обычно указывают в стилях этих крупных блоков.

### Не наследуемые свойства

Основные ненаследуемые свойства — это параметры позиционирования, размеров, отступов, фона, рамок:

```html
background, border, padding, margin, width, height, position и другие.
```

### Составные свойства
В CSS есть обычные свойства, управляющие одним параметром отображения, и есть составные свойства, управляющие одновременно несколькими параметрами. Например, свойство font. Оно задаёт сразу шесть параметров: размер и название шрифта, высоту строки и некоторые другие.

```css
font: 16px/26px "Arial", sans-serif;
```

Если значение обычного свойства не было задано в составном, то браузер при «расшифровке» использует исходное значение этого свойства.

### Типы значений: абсолютные и относительные
Абсолютные единицы измерения привязаны к настоящим физическим размерам и связаны между собой жёсткими пропорциями. Пиксели, px, используют чаще всего, остальные абсолютные единицы почти не применяют. Примеры абсолютных единиц измерения:

```css
font-size: 1cm;
font-size: 10mm;
font-size: 38px;
```

Относительные единицы измерения описывают значения, которые зависят от других значений. Например, ширина элемента в процентах зависит от ширины родительского элемента, а ширина элемента в em зависит от размера шрифта самого элемента. К относительным единицам относятся em, rem, vh, vw и некоторые другие, ну и, конечно же, проценты.

### Стили по умолчанию
Некоторым элементам можно не задавать никаких стилей, но у них всё равно будет какое-то оформление. Например, у списка `<ul>` есть отступы и маркеры. Такие стили называются стилями по умолчанию и задаются внутри браузерных стилей изначально. Их можно переопределить или сбросить, задав другие значения свойств элементу.

### Каскадирование
Когда браузер отрисовывает страницу, он должен определить итоговый вид каждого HTML-элемента. Для этого он собирает все CSS-правила, которые относятся к каждому элементу, ведь на элемент могут влиять сразу несколько CSS-правил. Механизм комбинирования стилей из разных источников в итоговый набор свойств и значений для каждого тега называется каскадностью. Например, есть такой элемент в разметке:

```html
<p class="beloved-color">Зелёный - мой любимый цвет</p>
```

Заданные стили:

```css
.beloved-color { color: green; }
Браузерные стили:

margin: 1em 0;
Итоговые стили:

color: green;
margin: 1em 0;
```

### Конфликт свойств
На один элемент могут действовать несколько CSS-правил. Если в этих правилах есть одинаковые свойства с разными значениями, то возникает конфликт. Например:

```css
ul { list-style: disc; }
.blog-navigation ul { list-style: none; }
```

Браузеру нужно как-то решать, какими будут итоговые значения конфликтующих свойств. Конфликт разрешается максимум за три шага. Если на текущем шаге определиться не удалось, то выполняется следующий шаг. Вот эти шаги:

Сравниваются приоритеты стилевых файлов, в которых находятся конфликтующие свойства. Например, авторские (то есть наши) стили приоритетнее браузерных.
Сравнивается специфичность селекторов у CSS-правил с конфликтующими свойствами. Например, селектор по классу более специфичен, чем селектор по тегу.
Побеждает то свойство, которое находится ниже в коде.
Каскад работает и внутри CSS-правил.

### Встраивание и подключение внешних стилей
Внешние стили подключаются через тег `<link>`

```html
<link rel="stylesheet" href="style.css">
```

Встраивание стилей в тег `<style>`. Его обычно размещают внутри `<head>`:

```html
<head>
  <style>
    CSS-код
  </style>
</head>
```

Такой способ используется для оптимизации загрузки страницы, ведь в таком случае браузер не будет отправлять дополнительных запросов на сервер.

Встраивание в атрибут style:

```html
<div style="width: 50%;"></div>
```

Свойства и значения, прописанные таким образом, применятся точечно к одному элементу.

Обычно использование этого способа считается плохой практикой. Но иногда в виде исключения бывает удобнее воспользоваться встраиванием стилей в атрибут style, чем писать отдельные CSS-правила. Например, когда нужно управлять стилями именно из разметки, и создавать отдельные классы при этом будет излишне. Так бывает, когда какие-то стилевые параметры устанавливаются с помощью сторонних программ или другими людьми, например, через CMS.






# «Оформление текста»
### Свойство font-size
Управляет размером шрифта. Значение свойства задаёт желаемую высоту символа шрифта. Причём единицы измерения могут быть абсолютными или относительными.

Самая часто используемая единица измерения размера шрифта — пиксели px:

```css
p {
  font-size: 20px;
}
```

Но, чтобы при изменении основного размера шрифта родителя его дочерние элементы пропорционально меняли свои размеры шрифта, есть специальная единица измерения — em.

Величина 1em — это такой же размер шрифта, что и у родителя. Соответственно, если нужно, чтобы шрифт дочернего элемента был всегда в 2 раза больше родительского, то надо задать значение 2em:

```css
h1 {
  font-size: 2em;
}
```

### Свойство line-height
Свойство управляет высотой строки или межстрочным интервалом.

По умолчанию это свойство имеет значение normal. Оно указывает браузеру, что межстрочный интервал нужно подобрать автоматически, исходя из размера шрифта. Спецификация рекомендует устанавливать его в пределах 100-120% от размера шрифта. То есть:

```css
p {
  font-size: 10px;
  line-height: normal; /* значение будет примерно 12px */
}
```

Значение normal позволяет всем нестилизованным текстам выглядеть удобочитаемо. Однако, если есть необходимость отойти от стилизации по умолчанию, line-height можно задать фиксированное абсолютное значение в px.

```css
p {
  font-size: 16px;
  line-height: 26px;
}
```

Если нужно задать line-height относительное значение, но не такое, как normal, то значение задаётся в процентах или в виде множителя. В таком случае браузер вычисляет значение динамически в зависимости от font-size:

```css
p {
  font-size: 10px;
  line-height: 150%; /* вычисленное значение: 10px * 150% = 15px */
  line-height: 2;    /* вычисленное значение: 10px * 2 = 20px */
}
```

Относительные значения более гибкие, чем абсолютные. Но для простых сайтов фиксированных font-size и line-height будет вполне достаточно.

### Свойство font-family
В значении этого свойства указывается список названий шрифтов, перечисленных через запятую. В начале списка располагают самый желаемый шрифт, затем менее желаемый, а в самом конце списка — общий тип шрифта. Браузер проходит по списку слева направо и использует первый найденный в системе или на сайте шрифт. Если название шрифта состоит из нескольких слов, то его нужно заключать в кавычки.

```css
body {
  font-family: "PT Sans", "Arial", sans-serif;
}
```

### Свойство font-weight
Свойство задаёт насыщенность или толщину шрифта. Шрифт может быть жирнее или тоньше обычного начертания. В качестве значения можно использовать ключевое слово или число. Самые часто встречающиеся значения:

400 или normal — обычный шрифт, значение по умолчанию;

700 или bold — жирный шрифт.

Например:

```css
h1 {
  font-weight: 400; /* то же самое что и normal */
}

p {
  font-weight: bold; /* то же самое что и 700 */
}
```

### Свойство text-align
Описывает, как выравнивается текст и другие инлайновые элементы (изображения, инлайн-блоки, инлайн-таблицы и другие) внутри блока по горизонтали.

Свойство может принимать следующие значения:

```css
left — выравнивание по левому краю блока, это значение по умолчанию;
right — по правому краю блока;
center — по центру блока;
justify — по ширине блока, при этом слова в строке будут размещаться так, чтобы занять равномерно всё пространство строки (пробелы между словами в таком случае становятся неравномерными, так как браузер «растягивает» слова в строке).
```

Важно помнить, что свойство text-align применяется именно к самому блоку-контейнеру, внутри которого находится текстовый контент:

HTML:
```html
<p>
  Я текст внутри абзаца
</p>
```

CSS:
```css
p {
  text-align: center;
}
```

### Свойство vertical-align
Свойством можно выравнивать инлайновые элементы относительно содержащей его строки. Самый простой пример — выровнять картинку <img> по вертикали в текстовой строке.

У свойства vertical-align много значений, но самые часто используемые:

```css
top — выравнивание по верхнему краю строки;
middle — по середине строки;
bottom — по нижнему краю строки;
baseline — по базовой линии строки (значение по умолчанию).
```

В отличие от text-align свойство vertical-align задаётся самому элементу, а не содержащему его контейнеру:

HTML:
```html
<p>
  <img src="picture.png" alt="Я картинка">
  Я текст внутри абзаца
</p>
```
CSS:
```css
img {
  vertical-align: middle;
}
```

### Свойство color
Цветом текста можно управлять свойством color.

Цвет может быть задан в виде ключевого слова (полный список ключевых слов приводится в спецификации). Например:

```css
color: black; /* чёрный цвет */
color: red;   /* красный цвет */
color: white; /* белый цвет */
```

Ещё один вариант указания цвета — в виде шестнадцатеричного значения. В этом случае цвет формируется из красной, зелёной и синей составляющих, заданных в виде шестнадцатеричного числа от 00 до ff. Помимо шести, цветовой код может содержать три знака, в этом случае второй символ в цветовых составляющих дублируется первым:

```css
color: #000000; /* чёрный цвет */
color: #f00;    /* красный цвет, то же что #ff0000 */
color: #fff;    /* белый цвет, то же что #ffffff */
```

Если не хочется иметь дело с шестнадцатеричными значениями, можно воспользоваться специальной функцией rgb, в которой указывается цвет в более привычном десятичном виде в диапазоне от 0 до 255 также в виде трёх цветовых составляющих, перечисленных через запятую:

```css
color: rgb(0, 0, 0)       /* чёрный, то же что #000000 */
color: rgb(255, 0, 0)     /* красный, то же что #ff0000 */
color: rgb(255, 255, 255) /* белый, то же что #ffffff */
```
У функции rgb есть расширенная версия — rgba. В этом случае помимо указания цвета последним значением указывается степень непрозрачности цвета — alpha. Значение может быть от 0 (полностью прозрачный) до 1 (полностью непрозрачный):

```css
color: rgba(0, 0, 0, 0.5)      /* чёрный, непрозрачный на 50% */
color: rgba(255, 0, 0, 0.3)     /* красный, непрозрачный на 30% */
color: rgba(255, 255, 255, 0.9) /* белый, непрозрачный на 90% */
```


### Контраст цвета текста и фона
Фоновое изображение и фоновый цвет блока всегда должен достаточно сильно контрастировать с цветом текста в этом блоке. Чем больше контраст, тем удобнее этот текст читать в разных условиях освещённости и на разных устройствах. Поэтому если вы задаёте блоку фоновое изображение, нужно обязательно дополнительно задавать подходящий фоновый цвет. В этом случае, пока изображение загружается, или в случае, если оно совсем не загрузится, текст всё равно можно будет прочитать:

```html
p {
  /* идеальный контраст: цвет текста белый, цвет фона — чёрный */
  background-color: #000000;
  color: #ffffff;
}

span {
  /* плохой контраст: цвет текста и фона — серые */
  background-color: #cccccc;
  color: #dddddd;
}
```

### Свойство white-space, управление пробелами
Браузер игнорирует множественные пробелы и переносы строк в HTML-коде. С помощью свойства white-space можно управлять пробелами и переносами строк. Свойство принимает значения:

nowrap — схлопывает лишние пробелы и отображает весь текст одной строкой без переносов;
pre — сохраняет пробелы и переносы как в исходном коде аналогично тегу `<pre>`;
pre-wrap — работает как значение pre, но добавляет автоматические переносы, если текст не помещается в контейнер;
normal — режим по умолчанию: лишние пробелы и переносы строк схлопываются, текст переносится, пробелы в конце строк удаляются.

### Свойство text-decoration

Задаёт дополнительное оформление текста. Значения свойства:

```css
underline — подчёркивание;
line-through — зачёркивание;
overline — надчёркивание;
none — убирает вышеперечисленные эффекты.
```

К тексту можно одновременно применить несколько эффектов, если перечислить значения через пробел:

```html
p {
  text-decoration: underline; /* подчёркнутый текст */
}

span {
  /* подчёркнутый и зачёркнутый текст */
  text-decoration: underline line-through;
}
```

### Свойство text-decoration — составное. Оно раскладывается на отдельные свойства:

```css
text-decoration-line — вид линии: зачёркивание, подчёркивание или надчёркивание;
text-decoration-style — стиль линии, может принимать значения:
solid — сплошная линия;
double — двойная линия;
dotted — точечная линия;
dashed — пунктирная линия;
wavy — волнистая линия.
text-decoration-color — цвет линии.
```

### Свойство font-style
Свойством можно задать начертание текста. Его основные значения:

```css
normal — обычное начертание;
italic — курсивное начертание;
oblique — наклонное начертание.
```

Если задано значение italic, браузер будет пытаться найти в заданном шрифте отдельное курсивное начертание символов. В некоторых шрифтах отдельный курсив предусмотрен.

Если отдельного курсивного начертания в шрифте не предусмотрено, то браузер сделает текст наклонным, то есть сымитирует курсив. Что равноценно заданию тексту значения font-style: oblique.

### Свойство text-transform
С его помощью можно управлять регистром символов: делать буквы строчными (маленькими) или заглавными (большими). Значения свойства:

```css
lowercase — все строчные;
uppercase — все заглавные;
capitalize — каждое слово начинается с большой буквы;
none — отменяет изменение регистра.
```

### Отступы
Важный фактор того, что текст в блоке будет удобочитаемым, это наличие свободного пространства в блоке для этого текста. Вокруг текста должно быть достаточно «воздуха», он не должен «прилипать» к краям, ему не должно быть «тесно».

За отступы в CSS отвечают два свойства: padding задаёт внутренние отступы в блоке, а margin задаёт внешние отступы.





## Селекторы, часть 1

### Нелёгкая жизнь без селекторов

Селекторы позволяют очень точно указывать к каким элементам применять CSS-свойства. Селекторы — это наш снайперский прицел, в этой главе мы будем учиться им пользоваться.
Так как глава посвящёна «стрельбе свойствами по элементам», то тема биатлона подходит как нельзя кстати. В каждом задании вам нужно будет с помощью селекторов закрывать мишени.
Но для начала представим, что механизма селекторов не существует. Как в этом случае задавать CSS-свойства элементам? С помощью атрибута style. Например:

```html
<p style="color: red;">...</p>
```

### Селекторы по тегам

Задавать атрибут style для каждого тега неудобно и долго. Особенно, если тот же результат можно получить с помощью единственного CSS-правила, в котором используется селектор для тега li.

С помощью селекторов по именам тегов можно задать стили для всех элементов списка, изображений, абзацев и так далее. Эти селекторы содержат имя тега без символов < и >. Например:

```html
li {
  /* стили для элементов списка */
}
```

Одно правило может относиться сразу к нескольким селекторам, в таком случае селекторы перечисляются через запятую:

```html
a, img {
  /* стили для ссылок и изображений */
}
```

### Селекторы по классам

Класс — это один из атрибутов тегов. Выглядит он вот так:

```html
<li class="first"></li>
```

Этот атрибут особенный, так как в CSS существует возможность выбирать элементы по классу. Делается это с помощью такого селектора: .имя_класса. Например:

```css
.first {
  /* стили для класса first */
}
```

Имена классов могут состоять из латинских символов, цифр и знаков - и _. Имя класса должно начинаться с латинской буквы.

### Отрабатываем селекторы по классам

Синтаксис CSS позволяет выбирать элементы не только по одному классу или тегу. Можно, например, выбрать элемент одновременно по тегу и по классу или же элемент с двумя классами сразу. Для этого селектор составляется просто одной строкой из всех желаемых «частей» без пробелов. Давайте рассмотрим примеры.
В селекторе по тегу и классу первым пишется название тега, а потом идёт класс:

```html
/* выбор всех тегов ul с классом target */
ul.target {...}

<ul class="target"></ul>
```

Если у элемента задано несколько классов, в HTML и в CSS-селекторе они могут идти в разном порядке — это не будет влиять на выборку элементов:

```html
/* выбор элементов с двумя классами: text и green */
.text.green {...}

<span class="text green"></span>
<p class="green text"></p>
```

Количество классов в селекторе может быть любым:

```css
/* выбор тегов span с четырьмя классами: underlined, red, big и text */
span.underlined.red.big.text {...}
```

```html
<span class="underlined red big text"></span>
```

### Контекстные селекторы

Селектор может состоять из нескольких частей, разделённых пробелом, например:

```css
p strong { ... }
ul .hit { ... }
.footer .menu a { ... }
```

Такие селекторы называют контекстными или вложенными. Их используют для того, чтобы применить стили к элементу, только если он вложен в нужный элемент.
Например, селектор .menu a сработает для ссылки a только в том случае, если она расположена внутри элемента с классом .menu.
Читать их проще всего справа налево:

```css
/* выбрать все теги strong внутри тегов p */
p strong { ... }

/* выбрать все элементы с классом .hit внутри тегов ul */
ul .hit { ... }

/* выбрать все ссылки внутри элементов с классом .menu,
   которые лежат внутри элементов с классом .footer */
.footer .menu a { ... }
```

Таким образом, можно задавать элементам различные стили в зависимости от их контекста. Если ссылка расположена внутри меню, сделать её крупнее, а если внутри основного текста, то задать ей нужный цвет

### Соседние селекторы

Контекстные селекторы используются для вложенных друг в друга элементов, а соседние — для расположенных рядом.
Например, теги `<li>` в списке являются соседними по отношению друг к другу и вложенными в тег `<ul>`.
Соседние селекторы записываются с помощью знака +, например, селектор1 + селектор2. Стили применятся к элементу, подходящему под селектор2, только если сразу перед ним расположен элемент, подходящий под селектор1.
Пример. Есть два элемента списка:

```html
<ul>
  <li class="hit"></li>
  <li class="miss"></li>
</ul>
```

Селектор .hit + .miss применит стили к элементу с классом miss, так как перед ним есть элемент с классом hit.
Селектор .hit + li, а также селектор li + .miss, или даже li + li тоже применит стили к элементу с классом miss, то есть ко второму элементу списка.
А вот селектор .miss + .hit не сработает, так как элемент с классом miss находится после элемента с классом hit в разметке.


### Контекстные и соседние селекторы

Селекторы в CSS можно очень гибко комбинировать. В частности, можно комбинировать контекстные и соседние селекторы

Псевдокласс добавляется к селектору c помощью символа :, вот так селектор:псевдокласс. Например:

```css
a:visited { ... }
li:last-child { ... }
.alert:hover { ... }
```

Знакомство с псевдоклассами мы начнём с first-child и last-child.
Псевдокласс first-child позволяет выбрать первый дочерний элемент родителя, а last-child — последний дочерний элемент. Например:
li:last-child { ... }
Этот селектор выберет последний элемент списка.

### Псевдокласс :nth-child

Псевдоклассы из предыдущего примера относятся к семейству псевдоклассов, помогающих выбирать элементы по их расположению.
Вспомним задание 4. В нём каждому тегу `<li>` был задан собственный класс. Используя классы, мы могли выбрать любой из пяти тегов. Если бы тегов было десять, то пришлось бы использовать десять разных классов.
С помощью псевдокласса nth-child можно выбирать теги по порядковому номеру, не используя классы. Синтаксис псевдокласса: селектор:nth-child(выражение). Выражением может быть число или формула. Например:

```css
1. li:nth-child(2) { ... }
2. li:nth-child(4) { ... }
3. li:nth-child(2n) { ... }
```

Первый селектор выберет второй элемент списка, второй селектор — четвёртый элемент списка, третий селектор — все чётные элементы.

### :nth-child и контекстные селекторы

Селекторы с псевдоклассами хорошо сочетаются с контекстными селекторами.
Например, следующий селектор выберет третий тег `<li>` внутри блока с классом shooter-2.

```css
.shooter-2 li:nth-child(3) { ... }
```

Селектор не обязательно должен заканчиваться псевдоклассом. Например, следующий селектор выберет элемент с классом .text в четвёртом элементе списка <li>.

```css
li:nth-child(4) .text { ... }
```

### Псевдокласс :hover

Некоторые псевдоклассы позволяют выбирать элементы, с которыми взаимодействует пользователь. Сначала познакомимся с псевдоклассом :hover.
Этот псевдокласс позволяет выбрать элемент, когда на него наведён курсор мыши и кнопка мыши не нажата. Примеры:

```css
1. a:hover { ... }
2. tr:hover { ... }
3 .menu-item:hover { ... }
```

Первый селектор выбирает ссылку, второй строку таблицы, третий элемент с классом menu-item, но только в том случае, если на них наведён курсор мыши.

Благодаря этому псевдоклассу можно добавлять в интерфейс динамику и интерактивность, так как элементы начинают реагировать на действия пользователя, изменяя свой внешний вид.

### Динамические эффекты с помощью :hover

Интересовались ли вы, как с помощью CSS создаются выпадающие меню?
Львиная доля динамических эффектов, создаваемых с помощью CSS, опираются на несколько псевдоклассов, главный из которых, конечно же, :hover. Весь секрет заключается в сочетании контекстных селекторов и псевдоклассов. Посмотрите на пример:

```css
li.top ul.submenu {
  display: none;
}

li.top:hover ul.submenu {
  display: block;
}
```

Первое правило прячет список-подменю. Второе правило гласит: «если на верхний пункт меню, в котором находится подменю, наведут курсор, то надо показать подменю». Вот так всё просто.
Общий принцип такой: родительский элемент реагирует на наведение мыши и изменяет свойства элементов-потомков. То есть всё работает на контекстных селекторах вида селектор1:hover селектор2.


### Псевдоклассы :link, :visited и :active

Отвлечёмся от биатлона и познакомимся с псевдоклассами для ссылок.

```css
●	:link выбирает ещё не посещённые ссылки.
●	:visited выбирает посещённые ссылки.
●	:active выбирает активные ссылки (кнопка мыши зажата на ссылке).
```

Пример задания CSS-правил для ссылок:

```css
a:link { ... }
a:visited { ... }
a:hover { ... }
a:active { ... }
```

Обратите внимание на порядок правил. Если их расположить по-другому, то некоторые могут не сработать.

### Псевдокласс :focus

Псевдокласс :focus позволяет выбрать элемент, который в данный момент в фокусе. Например, текстовое поле, в которое установлен курсор, находится в фокусе.
В фокусе могут быть не только текстовые поля. Если вы переключаетесь между элементами веб-страницы с помощью клавиши tab, то в фокус будут попадать ссылки.
Пример использования псевдокласса:

```css
input:focus {
  /* стили для поля в фокусе */
}
```

### Селекторы атрибутов

Ранее мы познакомились с атрибутом class и специальными селекторами по классу. Существуют селекторы, которые позволяют выбирать элементы по любым атрибутам.
Чаще всего такие селекторы используются при работе с формами, так как поля форм имеют атрибут type с разными значениями.
Селекторы атрибутов записываются с использованием квадратных скобок: элемент[атрибут]. Примеры селекторов:

```css
1. input[checked] { ... }
2. input[type="text"] { ... }
```

Первый селектор выберет поля формы, у которых есть атрибут checked, второй селектор выберет поля формы, у которых атрибут type имеет значение text.

### Селектор по id

Существует ещё один HTML-атрибут, для которого существует специальный селектор. Этот атрибут id (идентификатор), а селектор записывается с помощью символа #, например, #some-id.
На значение id распространяются те же ограничения, что и на имя класса. Также id должен быть уникальным на странице.
Пример:

```html
<p id="greeting">Приветствие!</p>
```

```css
CSS#greeting {
  ...
}
```

Использование селекторов по id при оформлении считается плохой практикой. Существуют редкие исключения из этого правила, например, при оживлении слайдера на чистом CSS.


## Глава 6. Наследование и каскадирование

### Иерархическое дерево

HTML-документ представляет собой иерархическое дерево. Это означает, что у каждого элемента (кроме корневого) есть только один родитель, то есть элемент, внутри которого он располагается. У корневого раздела родитель отсутствует. Рассмотрим простейшую страницу:

```html
<html>
   <head></head>
   <body>
      <p>Текст документа</p>
      <p class="text">Выделенная <span>строка</span></p>
   </body>
</html>
```

### Наследование

Наследование в CSS — механизм, с помощью которого значения свойств элемента-родителя передаются его элементам-потомкам.
Стили, присвоенные некоторому элементу, наследуются всеми потомками (вложенными элементами), если они не переопределены явно. Например, размер шрифта и его цвет достаточно применить к body, чтобы все элементы внутри имели те же свойства.
Наследование позволяет сократить размер таблицы стилей, но если стилей много, то отследить какой родительский элемент установил некоторое свойство, становится сложнее.

### Наследование «на пальцах»

Давайте на простых примерах подробнее разберёмся, в чём же преимущество наследования.
Рассмотрим пример:

```html
<p class="text">Cтрока c выделенным <span>словом</span></p>
```

Представим, что нам нужно установить красный цвет текста для всего текста. Зададим CSS-свойства следующим образом:

```css
.text {
  color: red;
}
```

Благодаря наследованию цвет текста в теге span автоматически станет красным:
Cтрока c выделенным словом
А так бы выглядел результат, если бы наследование не работало:
Cтрока c выделенным словом
Нам пришлось бы отдельно прописывать цвет текста для тега span. И тогда установка таких простых свойств как стиль шрифта стала бы большой проблемой: нужно было бы задавать свойства для всех возможных вложенных тегов.

### Ещё немного про наследование

Наверняка вы обращали внимание, что не все свойства наследуются тегами-потомками от их родителей.
Действительно, было бы странно, если бы свойство border автоматически устанавливалось для всех вложенных элементов.
Например, для этого куска кода:

```html
<p class="bordered">Cтрока c выделенным <span>словом</span></p>
```

Установим CSS-свойство:

```css
.bordered {
  border: 1px solid green;
}
```

Если бы наследовались все свойства, то результат бы выглядел так:
Cтрока c выделенным словом
На самом деле граница будет нарисована только у тега p.
О том, какие именно свойства наследуются, мы расскажем в следующих заданиях.

### Наследуемые свойства

К наследуемым свойствам относятся в первую очередь свойства, определяющие параметры отображения текста:

```css
font-size, font-family, font-style, font-weight, color, text-align, text-transform, text-indent, line-height, letter-spacing, word-spacing, white-space, direction и т. д.
```

Также к наследуемым свойствам относятся list-style, cursor, visibility, border-collapse и некоторые другие. Но они используются значительно реже.

Эти свойства можно и нужно задавать через предков, следуя семантике документа.
Например, параметры текста зачастую не меняются в пределах отдельных блоков страницы: меню, основного содержания, информационных панелей. Поэтому общие параметры текста (цвет, размер, гарнитура) обычно указывают в стилях самих блоков.

### Ненаследуемые свойства

В предыдущем задании мы перечислили основные наследуемые свойства. Все остальные относятся к ненаследуемым. Это параметры позиционирования, размеров, отступов, фона, рамок и т. д.
А именно:

```css
background, border, padding, margin, width, height, position и др.
```

Не наследуются они из соображений здравого смысла. Например: если для какого-либо блока установлен внутренний отступ, автоматически выставлять такой же отступ каждому вложенному элементу нет никакой надобности. Эти параметры чаще всего уникальны для каждого отдельного блока.

### Принудительное наследование

Для каждого свойства может быть задано значение inherit.
Оно означает, что данное свойство принимает такое же значение, как и у родительского элемента. Значение inherit может быть использовано для усиления наследуемых значений, а также в свойствах, которые обычно не наследуются.
Запись выглядит следующим образом:

```css
p {
  background: inherit;
}
```

В данном случае у тегов p свойство background будет таким же, как и у их родительских тегов.

### Каскадирование

CSS расшифровывается как «Cascading Style Sheets» или «каскадные таблицы стилей».
Каскадность обозначает, что к одному и тому же элементу может применяться несколько CSS-правил (наборов CSS-свойств). Среди этих свойств могут быть и конфликтующие между собой. Поэтому существуют инструкции, которые определяют, каким будет финальный набор свойств элемента.
Например, для элемента:

```html
<p class="text" style="color: red;"></p>
```

CSS-правила существуют как минимум в трёх разных местах:

1.	в подключаемом файле style.css для селекторов p или .text;
2.	в атрибуте style;
3.	в стандартных стилях отображения, встроенных в браузер.

Каскадирование как раз и определяет, какие именно свойства из этих источников применятся к данному абзацу.
Имеется три основные концепции, управляющие порядком, в котором применяются CSS-свойства:
1.	важность;
2.	специфичность;
3.	порядок исходного кода.
Самыми важными для нас являются последние две и подробнее о них мы поговорим отдельно.

### Битва за курочку

Перед тем как разбирать сложные правила работы каскадирования, расчёта специфичности и определения приоритетов, потренируемся на котиках.
Разберём пример. Вот HTML-код, в котором есть абзац с двумя классами:

```html
<p class="red blue">Синий или красный?</p>
```

А вот CSS-код c двумя правилами для этих классов:

```css
.blue {
  color: blue;
}

.red {
  color: red;
}
```

Вопрос: какого цвета будет текст абзаца? Какое из CSS-правил приоритетнее?
Ответ: красного цвета, второе правило приоритетнее.
Это происходит потому, что селекторы у правил одинакового типа, и соответственно обладают одинаковой специфичностью. В таком случае более высоким приоритетом обладает то правило, которое расположено в CSS-коде ниже. В нашем случае это правило для класса red.
В этой серии заданий вам нельзя менять значения CSS-свойств, но можно изменять селекторы или менять порядок CSS-правил в коде.

### Битва за курочку. Раунд второй

Чуть более сложный пример. Тот же HTML:

```html
<p class="red blue">Синий или красный?</p>
```

Немного другой CSS:

```css
p.blue {
  color: blue;
}

.red {
  color: red;
}
```

В этом случае текст абзаца будет синим. Происходит это потому, что селектор p.blue более специфичный, чем селектор .red.
Простое объяснение специфичности звучит так:
Чем меньшее количество элементов потенциально может выбрать селектор, тем он специфичнее.
В нашем примере селектор .red выберет все теги с нужным классом, а селектор p.blue выберет только абзацы с нужным классом.
Заметьте, что в этом задании одно из CSS-правил вынесено в заблокированный HTML-код, а вам нужно победить его, усилив другое CSS-правило.


### Битва за курочку. Раунд третий

А теперь посмотрим, как ведут себя контекстные селекторы.

```html
<div class="experiment">
  <p class="red blue">Синий или красный?</p>
</div>
```

И в CSS используем контекстный селектор для второго правила:

```css
p.blue {
  color: blue;
}

.experiment .red {
  color: red;
}
```

### Битва за курочку. Борьба накаляется

Как вы уже знаете, существуют селекторы не только по классам, но и по id. Они начинаются с решётки #.

HTML:

```html
<div id="experiment-1" class="experiment">
  <p class="red blue">Синий или красный?</p>
</div>
```

CSS:

```css
#experiment-1 .blue {
  color: blue;
}
.experiment .red {
  color: red;
}
```

Особенность атрибута id заключается в том, что его значение должно быть уникальным в пределах страницы. То есть, может существовать только один тег с определённым значением id.
Получается, что селектор по id может выбрать только один элемент. И поэтому он на порядок специфичнее селекторов по тегам, классам, а также комбинаций этих селекторов.


### Битва за курочку. Запрещённый приём

Битва подходит к концу, и чтобы удержать победу, Рудольф решается на запрещённый приём: он прописывает стили с помощью атрибута style прямо в теге курочки.
CSS-правила, которые прописаны в style обладают наивысшим приоритетом. Такой способ задания стилей не приветствуется в профессиональной вёрстке сайтов и годится только для создания быстрых прототипов. Поэтому мы и назвали этот приём запрещённым.
Однако существует способ переопределить из подключаемых CSS-файлов даже стили, заданные в атрибуте style. Для этого нужно использовать ключевое слово !important. Оно задаёт CSS-свойству усиленный приоритет. Вот пример:
HTML:

```html
<p style="color: red;" class="blue">Синий или красный?</p>
```

CSS:

```css
.blue {
  color: blue !important;
}
```

Цвет текста в этом примере будет синим.
При вёрстке не рекомендуется часто использовать !important. По возможности старайтесь обходиться без него.


### Ещё одна задачка на специфичность

Как вы уже догадались, самым главным механизмом для определения приоритетов стилей является специфичность. Поэтому давайте ещё немного потренируемся работать с ней.
Рассмотрим пример: на полу в коробке сидит кот

```html
<div id="floor">
  <span class="cat-in-box">Кексик</span>
</div>
```

Допустим в стилях существуют следующие определения:

```css
span {
  background-color: #27ae60; /* Зелёный */
}

div span {
  background-color: #2980b9; /* Синий */
}

#floor .cat-in-box {
  background-color: #34495e; /* Мокрый асфальт */
}

.cat-in-box {
  background-color: #8e44ad; /* Фиолетовый */
}

#floor span {
  background-color: #c0392b; /* Красный */
}

div .cat-in-box {
  background-color: #e67e22; /* Оранжевый */
}
```

А теперь вопрос на засыпку: какого цвета будет коробка? Сначала сделайте предположение, а затем проверьте.
Почему именно такой и как это определяется мы расскажем в следующем задании.


### Расчёт значения специфичности

Вы вдоволь наигрались со специфичностью, а теперь пришло время изучить полные правила её вычисления.
Специфичность селектора разбивается на 4 группы — a, b, c, d:
●	если стиль встроенный, то есть определён как style="...", то а=1, иначе a=0;
●	значение b равно количеству идентификаторов (тех, которые начинаются с #) в селекторе;
●	значение c равно количеству классов, псевдоклассов и селекторов атрибутов;
●	значение d равно количеству селекторов типов элементов и псевдо-элементов.

После этого полученное значение приводится к числу (обычно в десятичной системе счисления). Селектор, обладающий большим значением специфичности, обладает и большим приоритетом.
Посчитаем специфичность в нашем примере:

Селектор	a, b, c, d	Число
span	0, 0, 0, 1	1
div.cat-in-box	0, 0, 1, 1	11
#floor.cat-in-box	0, 1, 1, 0	110
div span	0, 0, 0, 2	2
.cat-in-box	0, 0, 1, 0	10
#floor span	0, 1, 0, 1	101

Отсюда сразу видно, что в нашем примере самым приоритетным является селектор #floor.cat-in-box.

### Перекрёстное наследование

При создании стилей для сходных по внешнему виду или функциональности элементов, которые могут использоваться на странице неоднократно, очень удобно пользоваться перекрёстным наследованием.
Приём этот заключается в следующем:
1.	создаётся базовый стиль для таких элементов;
2.	определяются вспомогательные стили, которые применяются к элементам по мере надобности;
3.	элемент наследует базовый стиль и один или несколько вспомогательных.
Пример:
На странице используются кнопки разного назначения: для отправки форм, для сброса информации в полях формы, как элементы навигации и т. д.
Можно вынести общее оформление (размеры, отступы и так далее) для всех кнопок в отдельное CSS-правило для класса, например, .button.
А затем создать дополнительные CSS-правила, в которых будут определены только различающиеся свойства этих кнопок, например, цвет фона. Для этих правил можно использовать такие названия классов: .button-send, .button-clear, .button-navigation.
Каждая кнопка в HTML-коде будет иметь два класса: общий и дополнительный.

```html
<a class="button button-send">Отправить</a>
```



## Глава 7. Фоны, часть 1

### Cвойство background-color

Цвет фона можно задать с помощью CSS-свойства background-color.
Напомним, что цвета в CSS можно задавать в разных форматах: в шестнадцатеричном (или HEX), в RGB или RGBA, а также с помощью цветовых констант, таких как red или green.
Более подробно о цветах можно прочитать на странице HTML Colors или в переводной статье о теории цвета на Хабре.
Вот пример использования свойства:

```css
selector {
  background-color: #ff0000;
}
```

### Свойство background-image

Фоновое изображение можно задать с помощью CSS-свойства background-image. Делается это так:

```css
selector {
  background-image: url("адрес-картинки");
}
```

Адрес картинки обязательно заключается внутрь url("..."). Адреса фоновых картинок такие же, как и адреса обычных картинок, которые вы задавали в курсе про ссылки и изображения.
Элементу можно одновременно задавать и цвет фона, и фоновую картинку. В этом случае картинка будет отображаться поверх фонового цвета.


### Свойство background-repeat

По умолчанию фоновое изображение повторяется. Это хорошо заметно, когда оно меньше блока. Управлять этим поведением можно с помощью CSS-свойства background-repeat. У свойства 4 значения:
●	repeat — повторять во всех направлениях. Это значение по умолчанию.
●	repeat-x — повторять только по горизонтали.
●	repeat-y — повторять только по вертикали.
●	no-repeat — не повторять.

### Свойство background-position

Cвойство background-position управляет расположением фонового изображения. Значение свойства состоит из двух частей, разделенных пробелом: x y.
x задаёт расположение по горизонтали, а y по вертикали.
В качестве значения x можно использовать ключевые слова left, center, right, значения в процентах и в пикселях.
В качестве значения y можно использовать ключевые слова top, center, bottom, значения в процентах и в пикселях.
Примеры использования свойства:
background-position: 50% 50%;

```css
background-position: right bottom;
background-position: 50px 100px;
background-position: 0 100%;
background-position: left bottom;
```

Так сработают примеры:
1.	картинка будет по центру;
2.	правый нижний угол;
3.	отступ 50px от левого края и 100px от верхнего;
4.	левый нижний угол;
5.	левый нижний угол.

### Ещё немного background-position

Когда фоновое изображение больше блока, то оно обрезается. Управлять тем, какую часть изображения будет видно, также можно с помощью свойства background-position.
Иногда для этого удобно использовать относительные значения (проценты), а иногда абсолютные (пиксели).
Кстати, можно использовать не только положительные, но и отрицательные значения. А также комбинировать пиксели и проценты.

### Свойство background-attachment

Обычно фоновое изображение прокручивается вместе с содержимым блока. Это хорошо видно в мини-браузере. Прокрутите окно вниз и увидите, что фон поднимется наверх.
С помощью свойства background-attachment можно зафиксировать фон на месте и он не будет перемещаться при прокручивании.
Значение свойства:

●	scroll — фон прокручивается вместе с содержимым. Это значение по умолчанию.
●	fixed — фон не прокручивается, зафиксирован на одном месте.
Это тот случай, когда легче показать, чем объяснять: выполняйте задание и смотрите, как изменяется поведение фона при прокрутке

### Свойство background

Фон элемента можно задавать с помощью отдельных свойств: background-color, background-image и так далее. Получается довольно громоздкая запись.
Также задать фон можно с помощью сокращенного свойства background, в котором через пробел перечисляются его компоненты:

```css
background: [bc] [bi] [br] [bp] [ba];
/* Обозначения:
[bc] — background-color
[bi] — background-image
[br] — background-repeat
[bp] — background-position
[ba] — background-attachment
*/
```

Если какой-то компонент не указан, то берется значение по умолчанию. Ниже примеры.

```css
background: #e74c3c;
background: url("img.png") no-repeat;
background: url("img.png") 10px 20px;
```

В первом примере просто задан цвет фона.
Во втором примере задано не повторяющееся фоновое изображение, а также по умолчанию прозрачный цвет фона, расположение в левом верхнем углу.
В третьем примере задано фоновое изображение и его расположение, а также по умолчанию прозрачный цвет фона и режим повторения во все стороны.


### Формат JPEG

В последующих нескольких заданиях мы рассмотрим наиболее распространенные форматы изображений для веб. И разберемся, где и как их лучше использовать при вёрстке.
Первый формат — JPEG. Этот формат хорошо подходит для фотографий и картин и плохо подходит для схем, чертежей, текста и графики.
При сохранении изображения в формат JPEG можно задавать уровень качества. Это позволяет добиваться снижения веса файла при достаточно хорошем качестве изображения.
Однако, если установить уровень качества слишком низким, то появятся артефакты.
JPEG не поддерживает прозрачность, поэтому изображение в формате JPEG — это всегда прямоугольник. Можно имитировать прозрачность, если в графическом редакторе задать изображению такой же цвет фона, как и у контейнера фотографии.
Используйте JPEG для размещения фото с наилучшим соотношением "размер файла"/"качество".

### Формат PNG-8

На самом деле, формат PNG один. А PNG-8 и PNG-24 это его подтипы, а также режимы сохранения в Photoshop. Мы не будем глубоко вдаваться в детали, а разберем типовые особенности.
PNG-8 по характеристикам схож с форматом GIF. Он хорошо подходит для схем, чертежей, графиков и текста, а также изображений, где мало цветов. Максимальное количество цветов — 256.
PNG-8, как и GIF, поддерживает прозрачность. Это означает, что пиксель либо полностью прозрачный, либо полностью непрозрачный.

Если нужно сделать изображение с прозрачностью, то лучше задавать обводку такую же, как цвет фона. В фотошопе при сохранении обводка называется «Matte». Без обводки картинка будет выглядеть «обкусанной». Если фон неоднородный (градиент, 3 блок в мини-браузере), то PNG-8 с обводкой будет смотреться плохо.
Чем PNG лучше GIF? PNG более современный и свободный формат, а GIF более старый и проприетарный (за его использование могут потребовать деньги). Уровень сжатия, качество и другие характеристики примерно одинаковые, поэтому лучше всегда использовать PNG.

### Формат PNG-24

PNG-24 — отличнейший формат. Он хорошо подходит и для схем-чертежей-графиков-текста, и для сложных многоцветных изображений, так как поддерживает практически неограниченное количество цветов.
На фотографиях обычно он уступает JPEG по размеру файла, но превосходит по качеству изображения. Но иногда разница по размеру файла настолько некритична, что можно использовать PNG.
Самый главный плюс PNG-24 — это полноценная поддержка полупрозрачности, которой нет ни в одном другом формате. Поэтому в веб-разработке при вёрстке сложных фонов, графических элементов со сложными тенями и так далее альтернативы PNG-24 просто нет.
Давным-давно в IE была проблема с поддержкой полупрозрачных PNG, но в более поздних версиях IE (8+), таких проблем нет.
Сравните котика-PNG-8 с обводкой из предыдущего задания и котика-PNG-24 из этого задания. Особенно то, как выглядят их края на желтом блоке и блоке с градиентом.
Некоторые верстальщики перестают использовать PNG-8 и используют только PNG-24.

### Формат GIF

Наверное, единственная причина использовать GIF заключается в том, что он поддерживает анимированные изображения.
Во всех остальных случаях используйте PNG или JPEG (если речь идёт о фотографиях и PNG даёт слишком тяжёлый файл).

### Несколько фонов

Несколько фонов одному элементу можно задать с помощью множественных фонов. Эта и другие возможности рассмотрены в продолжении курса — «Рамки и фоны, часть 2».
А сейчас рассмотрим старую надёжную технику создания нескольких фонов.
Суть техники заключается в том, что мы вкладываем элементы друг в друга и делаем их одинакового размера, а затем каждому элементу задаём свой фон. То есть каждый элемент служит одним слоем фона.
Фоны вложенных элементов перекрывают друг друга: чем глубже элемент, тем выше его фон.
Кстати, для удобства ширину лучше задавать внешнему элементу (так как все вложенные будут той же ширины), а высоту самому глубокому, так как он растянет по высоте всех своих родителей.

### Эффекты с повторяющимся фоном

Повторяющийся фон, тот у которого repeat, repeat-x или repeat-y, часто используется для создания интересных декоративных эффектов.
Например:
●	стежки;
●	зазубренные края;
●	градиенты и тени.

Да, сейчас уже градиенты и тени можно делать с помощью CSS. Но иногда, когда тень или градиент достаточно сложные, проще использовать полупрозрачный PNG.
Самое главное при создании таких эффектов — выбрать картинку с нужным периодом. Она может быть очень маленькой и даст существенную экономию веса страницы.
Попрактикуемся. Только, пожалуйста, изменяйте режим повторения после того, как пропишете фоновые изображения. Так будет нагляднее.

### Спрайты

Спрайт — это одно большое изображение, в котором содержится много маленьких, как бы карта изображений. Вот живой пример (эта же картинка выведена на тёмном фоне внизу мини-браузера), который мы будем использовать в задании.
Спрайты используются, чтобы снизить количество запросов на сервер. Каждая маленькая картинка — это отдельный запрос, а чем меньше запросов, тем лучше. Поэтому маленькие картинки «склеивают» в одну большую.
Части спрайта отображают в элементах с небольшими размерами. Такому элементу задают картинку-спрайт в качестве фона и смещают её таким образом, чтобы была видна нужная её часть.
В спрайты обычно объединяют иконки и различные мелкие декоративные изображения. Кстати, есть сервисы для быстрого создания спрайтов и генерации CSS-кода для них, например, SpritePad.




## Глава 8. Селекторы, часть 2

### Объединение селекторов

Иногда может потребоваться выбрать элементы, которые одновременно удовлетворяют сразу нескольким условиям.
В CSS есть запись, которая фактически выполняет операцию логического умножения, «И». Селекторы, применяемые к одному элементу, в этом случае пишутся без пробелов:

```css
.class1.class2 { }
```

Стили будут применяться ко всем элементам, которые одновременно имеют класс class1 и class2. Ведь это же не новость для вас, что HTML-элементы могут одновременно иметь несколько классов. Например:

```html
<div class="class1 class2">Блок с двумя классами</div>
```

По такому же принципу можно объединять любое количество абсолютно разных селекторов. И чем больше селекторов вы объединяете, тем больше условий должно совпасть для применения стилей.
В программировании похожую операцию часто обозначают как &&. Например:

```js
if (firstSelector && secondSelector) { ... }
```

### Псевдокласс :not

Псевдокласс :not(селектор) является отрицающим селектором. С его помощью можно выбрать элементы, которые НЕ содержат указанный селектор:

```css
li:not(:last-child) { }
```

Этот селектор выберет все теги `<li>`, НЕ являющиеся последними в их родителе.
Псевдокласс :not похож на оператор ! в программировании:

```js
if (!selector) { ... }
```

В качестве селектора могут указываться псевдоклассы, теги, идентификаторы, классы и селекторы атрибутов. Нельзя использовать двойной псевдокласс :not, то есть конструкция :not(:not(...)) не сработает.

Также в комбинации с :not не применяются:
●	объединение селекторов: например, li:not(.heart.jack) — некорректный селектор;
●	псевдоэлементы: li:not(::after) — неправильная запись (подробнее о псевдоэлементах рассказано далее в курсе);
●	селекторы-потомки, групповые селекторы или комбинации: например, нельзя писать li:not(a span) или li:not(a + span).

### Комбинируем :not

Отрицающий селектор :not, как и любые другие селекторы, можно комбинировать с другими. Например:

```css
li:not(:first-child):not(:last-child) { }
```

Выберет все теги `<li>`, которые НЕ являются первыми и последними в их родителе.

### Псевдокласс :nth-last-child

В первом курсе про селекторы мы уже рассматривали псевдокласс :nth-child, сейчас посмотрим на :nth-last-child.
Псевдокласс :nth-last-child используется для добавления стиля к элементам на основе нумерации в дереве элементов. В отличие от псевдокласса :nth-child, отсчет ведется не от первого элемента, а от последнего. Вот и все различия.

### Псевдокласс :first-of-type

Псевдокласс :first-of-type очень похож на :first-child. Он выбирает первый дочерний элемент родителя, только с учетом типа элементов.
Например, в этом задании перед списками с картами есть блок с текстом. У списков и у блока с текстом общий родитель — body.

```html
<body>
  <div class="paper"> … </div>
  <ul class="cards"> … </ul>
  <ul class="cards"> … </ul>
</body>
```

Сравним две записи:

```css
ul:first-child {
  background-color: #ffffee;
}
ul:first-of-type {
  background-color: #ffffee;
}
```

Верхний селектор выбирает первый дочерний элемент в родителе, причем этот элемент должен быть ul. В нашем случае не выберется ничего, потому что первым дочерним элементом body является div.
Нижний селектор выбирает первый ul среди всех дочерних ul в своем родителе. В нашем случае будет выбрана первая строка с картами.

### Псевдокласс :last-of-type

В предыдущем задании мы рассмотрели псевдокласс :first-of-type.
Псевдокласс :last-of-type работает аналогично, только выбирает последний дочерний элемент родителя с учетом типа.
Пример записи:

```css
ul:last-of-type {
  ...
}
```

### Псевдокласс :nth-of-type

Псевдокласс :nth-of-type работает почти так же, как и :nth-child. Разница заключается в том, что он учитывает тип элемента.
Вы можете обратиться к разбору примера в пятом задании, чтобы разобраться в отличиях этих селекторов.
Еще пример. Если в текущем задании мы используем такие селекторы:

```css
ul:nth-child(2) { }
ul:nth-of-type(2) { }
```

То верхний cелектор выберет второй по счёту дочерний элемент и этот элемент должен быть ul. В нашем случае выберется первая строка карт.
А нижний селектор выберет второй по счету ul среди дочерних ul. В нашем случае выберется вторая строка карт.

Псевдокласс :nth-of-type также работает с ключевыми словами odd и even. Значение odd позволяет выбрать все нечётные элементы, а значение even - все чётные элементы указанного типа. Подробнее о работе с этими ключевыми словами рассказано в пошаговой демонстрации Использование псевдокласса :nth-child

### Псевдокласс :nth-last-of-type

Наверняка, вы и сами уже прекрасно догадались, как будет работать :nth-last-of-type.
Элементы выбираются по их расположению, отсчет ведется от конца, учитывается тип элемента.
Пример записи:

```css
ul:nth-last-of-type(2) { }
```

Когда набор элементов не очень большой, все эти псевдоклассы :nth-child, :nth-of-type, :nth-last-child, :nth-last-of-type можно легко заменить один другим.
На более сложных структурах зачастую бывает удобнее использовать только определённые из них. Например, когда нужно выделять второй элемент с конца, но количество элементов в списке изменяется.

### Cелектор последующих элементов

Ранее мы уже рассматривали соседние селекторы, которые записываются как селектор1 + селектор2.
Есть похожий селектор селектор1 ~ селектор2. Стили применятся к элементу, подходящему под селектор2, только если перед ним расположен элемент, подходящий под селектор1. Оба элемента должны принадлежать одному родителю.
Отличие от соседнего селектора состоит в том, что между элементами селектор1 и селектор2 могут находиться другие элементы. Поэтому будем называть селектор1 ~ селектор2 селектором следующих элементов.
Сравним:

```html
<ul class="cards">
  <li class="king diamond">
  <li class="queen heart">
  <li class="jack spade">
  <li class="ace heart">
  <li class="king club">
</ul>
```

```css
.queen.heart + li {
  background-color: #ffff99;
}

.king.diamond ~ li {
  background-color: #99ddff;
}
```

В первом случае выделится одна карта, расположенная сразу за червовой дамой, то есть пиковый валет.
Во втором случае выделятся все карты, которые стоят за бубновым королем, то есть червовая дама, пиковый валет, червовый туз и трефовый король.


### Псевдокласс :empty

Псевдокласс :empty, выбирает только те теги, у которых нет дочерних элементов (в том числе текстовых узлов). Учтите, что даже переход на новую строку считается текстовым узлом, помните об этом в процессе проектирования структуры страницы.
Пример:

```css
ul:empty {
  ...
}
```
В данном случае выберутся все пустые элементы ul.

### Псевдокласс :only-child

Псевдокласс :only-child пригодится, когда нужно прописать индивидуальные стили для элемента, который является единственным дочерним элементом внутри родительского контейнера.
Пример:

```css
li:only-child {
  ...
}
```

Сработает, когда этот `<li>` в списке единственный.
Cелектор :only-child эквивалентен селектору elem:last-child:first-child.

### Псевдокласс :only-of-type

Псевдокласс :only-of-type работает почти так же, как и :only-child. Отличие состоит в том, что он учитывает тип элемента.
Пример:

```css
p:only-of-type {
  ...
}
```

В данном случае стили будут применены к элементу p, если это единственный p внутри своего родителя.

### Псевдоэлемент ::before

Псевдоэлемент before позволяет с помощью CSS добавить псевдотег внутрь другого элемента и оформить его. Cодержимое псевдотега задаётся с помощью свойства content.
Например, у нас есть такой HTML:

```html
<div class="queen heart">
  <em>Дама</em>
</div>
```

Добавим CSS-правило с необычным селектором с двойным двоеточием:

```css
.heart::before { content: "Черви"; }
```

И HTML изменится вот так:

```html
<div class="queen heart">
  <before>Черви</before>
  <em>Дама</em>
</div>
```

Но! Исходный HTML-код не изменится, тег `<before>` не попадёт в код страницы, а будет «виртуально» существовать где-то в браузере. Поэтому мы и используем приставку псевдо.
Ведёт себя псевдотег так же, как обычный `<span>` с текстом. Ему можно задавать дополнительные стили, например:

```css
.heart::before {
  content: "Черви";
  color: red;
}
```

Чтобы псевдоэлемент появился, ему необходимо задать свойство content. Достаточно даже пустой строки в значении свойства — content: "";.

### Псевдоэлемент ::after

Псевдоэлемент after аналогичен before. Отличие заключается в том, что он добавляет псевдотег не в начало, а в конец элемента. Например:

```css
.heart::after { content: "Черви"; }
```

Даст такой результат:

```html
<div class="queen heart">
  <em>Дама</em>
  <after>Черви</after>
</div>
```

Псевдоэлементы before и after можно использовать одновременно. Это означает, что с помощью CSS вы можете добавить к любому элементу на странице два псевдоэлемента.

Обратите внимание, что псевдоэлементы пишутся с двойным двоеточием. Этим они отличаются от псевдоклассов, которые используют одинарное двоеточие.

### Позиционирование псевдоэлементов

Вы можете задавать псевдоэлементам любые CSS-свойства. Можно менять тип элемента, задавать ему позиционирование, отступы, фон и так далее.

Этими возможностями особенно часто пользуются при создании различных декоративных эффектов. Это очень удобно.
Во-первых, не нужно добавлять лишний тег под каждую очередную мелкую иконку.
Во-вторых, можно управлять этими иконками/декоративными элементами только с помощью CSS, что открывает огромный простор для создания интересных динамических эффектов.


### Фон для псевдоэлементов

Наша карта почти готова. Осталось сделать последний штрих — задать фоны самой карте и псевдоэлементам.
Кстати, мы перевернули нижнюю иконку с помощью CSS-свойства transform, которое будет рассмотрено в курсе про двумерные трансформации.

Также для управления размером фонового изображения мы использовали свойство background-size, которое рассмотрим в курсе про рамки и фоны.

### Псевдоэлементы ::first-line и ::first-letter

Отвлечемся от карт и обратимся к тексту.
Псевдоэлемент first-line задает стиль первой строки форматированного текста. Длина этой строки зависит от многих факторов, таких как используемый шрифт, размер окна браузера, ширина блока, языка и так далее. В правилах стиля допустимо использовать только свойства, относящиеся к шрифту, изменению цвета текста и фона.
Пример использования:

```css
p::first-line { }
```

Аналогично псевдоэлемент first-letter определяет стиль первого символа в тексте элемента, к которому добавляется. К этому псевдоэлементу могут
применяться только стилевые свойства, связанные со свойствами шрифта, полями, отступами, границами, цветом и фоном.
Пример использования:

```css
p::first-letter { }
```
